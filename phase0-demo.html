<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase0/Phase1 ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ‡ãƒ¢ - å‰å¾Œæ¯”è¼ƒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }

        h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        input, select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .canvas-box {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 20px;
        }

        .canvas-box h3 {
            margin-bottom: 15px;
            font-size: 16px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .canvas-box.before h3::before {
            content: "âŒ";
            font-size: 20px;
        }

        .canvas-box.after h3::before {
            content: "âœ…";
            font-size: 20px;
        }

        canvas {
            display: block;
            width: 100%;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #fff;
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 20px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 16px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: white;
            padding: 12px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }

        .info-item strong {
            display: block;
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .info-item span {
            font-size: 14px;
            color: #2c3e50;
            word-break: break-all;
        }

        @media (max-width: 768px) {
            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Phase0/Phase1 ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ ãƒ‡ãƒ¢</h1>
        <p class="subtitle">ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼ˆPhase0ï¼‰ã¨å­¦ç¿’å€¤ï¼ˆPhase1ï¼‰ã®ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°èª¿æ•´ - å‰å¾Œæ¯”è¼ƒ</p>

        <div class="controls">
            <div class="control-group" style="grid-column: 1 / -1;">
                <label for="phaseModeSelect">ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰</label>
                <select id="phaseModeSelect">
                    <option value="phase0">Phase0ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼‰</option>
                    <option value="phase1">Phase1ï¼ˆå­¦ç¿’å€¤ï¼‰</option>
                    <option value="compare">æ¯”è¼ƒãƒ¢ãƒ¼ãƒ‰ï¼ˆPhase0 vs Phase1ï¼‰</option>
                </select>
            </div>
            <div class="control-group" id="unlearnedPairAlgorithmGroup" style="grid-column: 1 / -1; display: none;">
                <label for="unlearnedPairAlgorithmSelect">æœªå­¦ç¿’ãƒšã‚¢ã®å‡¦ç†æ–¹æ³•ï¼ˆPhase1ãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰</label>
                <select id="unlearnedPairAlgorithmSelect">
                    <option value="average">æœªå­¦ç¿’ãƒšã‚¢ã«å¹³å‡å€¤ã‚’ä½¿ç”¨</option>
                    <option value="phase0">Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯</option>
                    <option value="phase0_scaled">Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ Ã— ä¿‚æ•°ï¼ˆå¹…ã«å¿œã˜ãŸèª¿æ•´ï¼‰</option>
                </select>
            </div>
            <div class="control-group" id="showUnlearnedPairsGroup" style="grid-column: 1 / -1; display: none;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="showUnlearnedPairsCheckbox">
                    <span>æœªå­¦ç¿’ãƒšã‚¢ã‚’å¯è¦–åŒ–ï¼ˆPhase1ãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰</span>
                </label>
            </div>
            <div class="control-group" id="blendRatioGroup" style="grid-column: 1 / -1; display: none;">
                <label for="blendRatioSlider">Phase0ã¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ï¼ˆPhase1ãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="min-width: 80px; font-size: 12px; color: #666;">Phase0ã®ã¿</span>
                    <input type="range" id="blendRatioSlider" min="0" max="100" value="0" step="1" style="flex: 1;">
                    <span style="min-width: 80px; font-size: 12px; color: #666; text-align: right;">Phase1ã®ã¿</span>
                    <span id="blendRatioValue" style="min-width: 60px; text-align: right; font-weight: 600;">0%</span>
                </div>
                <div style="margin-top: 5px; font-size: 11px; color: #888;">
                    <span id="blendRatioDescription">Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’100%ä½¿ç”¨</span>
                </div>
            </div>
            <div class="control-group">
                <label for="textInput">æ–‡å­—åˆ—</label>
                <input type="text" id="textInput" value="WAVE" placeholder="æ–‡å­—åˆ—ã‚’å…¥åŠ›">
            </div>
            <div class="control-group">
                <label for="fontSelect">ãƒ•ã‚©ãƒ³ãƒˆ</label>
                <select id="fontSelect">
                    <option value="">èª­ã¿è¾¼ã¿ä¸­...</option>
                </select>
            </div>
            <div class="control-group">
                <label for="fontCustomInput">ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆåï¼ˆç›´æ¥å…¥åŠ›å¯ï¼‰</label>
                <input type="text" id="fontCustomInput" placeholder="ä¾‹: ãƒ•ã‚©ãƒ³ãƒˆåã‚’å…¥åŠ›">
            </div>
            <div class="control-group">
                <label for="styleSelect">ã‚¹ã‚¿ã‚¤ãƒ«</label>
                <select id="styleSelect">
                    <option value="default">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ</option>
                    <option value="å’Œãƒ¢ãƒ€ãƒ³">å’Œãƒ¢ãƒ€ãƒ³</option>
                    <option value="åŒ—æ¬§">åŒ—æ¬§</option>
                    <option value="ãƒ¢ãƒ€ãƒ³">ãƒ¢ãƒ€ãƒ³</option>
                    <option value="ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«">ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«</option>
                </select>
            </div>
            <div class="control-group">
                <label for="fontSizeInput">ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º (px)</label>
                <input type="number" id="fontSizeInput" value="64" min="20" max="200">
            </div>
            <div class="control-group" style="grid-column: 1 / -1;">
                <label for="trackingSlider">å…¨ä½“ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" id="trackingSlider" min="-50" max="50" value="0" step="1" style="flex: 1;">
                    <span id="trackingValue" style="min-width: 60px; text-align: right; font-weight: 600;">0px</span>
                </div>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <div class="canvas-box before">
                <h3 id="canvasBeforeLabel">ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å‰ï¼ˆå›ºå®šãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ï¼‰</h3>
                <canvas id="canvasBefore" width="600" height="200"></canvas>
            </div>
            <div class="canvas-box after">
                <h3 id="canvasAfterLabel">ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å¾Œï¼ˆPhase0ãƒ­ã‚¸ãƒƒã‚¯é©ç”¨ï¼‰</h3>
                <canvas id="canvasAfter" width="600" height="200"></canvas>
            </div>
        </div>

        <div class="info-panel">
            <h3>è¨ˆç®—è©³ç´°</h3>
            <div class="info-grid">
                <div class="info-item">
                    <strong>ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼</strong>
                    <span id="infoFontFamily">-</span>
                </div>
                <div class="info-item">
                    <strong>åŸºæœ¬ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°</strong>
                    <span id="infoBaseTracking">-</span>
                </div>
                <div class="info-item">
                    <strong>æ–‡å­—ã‚«ãƒ†ã‚´ãƒª</strong>
                    <span id="infoCharTypes">-</span>
                </div>
                <div class="info-item">
                    <strong>ãƒšã‚¢è£œæ­£</strong>
                    <span id="infoPairAdjusts">-</span>
                </div>
                <div class="info-item">
                    <strong>é»’å¯†åº¦è£œæ­£</strong>
                    <span id="infoDensityAdjusts">-</span>
                </div>
                <div class="info-item">
                    <strong>æœ€çµ‚ã‚®ãƒ£ãƒƒãƒ—</strong>
                <span id="infoFinalGaps">-</span>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h3>æ–‡å­—ã”ã¨ã®è©³ç´°æƒ…å ±ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰</h3>
            <div id="charDetails" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                <!-- æ–‡å­—ã”ã¨ã®æƒ…å ±ãŒã“ã“ã«å‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            </div>
        </div>

        <div class="info-panel" id="evaluationPanel" style="display: none;">
            <h3>ğŸ“Š æ©Ÿèƒ½è©•ä¾¡ãƒ‘ãƒãƒ«ï¼ˆPhase1ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿è¡¨ç¤ºï¼‰</h3>
            <p style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">
                ã“ã®ãƒ‘ãƒãƒ«ã§ã¯ã€Œå¹…ã‚¢ãƒ³ã‚«ãƒ¼ã€ã¨ã€ŒPhase0ã¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ã€ã®åŠ¹æœã‚’æ•°å€¤ã§ç¢ºèªã§ãã¾ã™ã€‚
            </p>
            <div class="info-grid">
                <div class="info-item">
                    <strong>å¹…ã‚¢ãƒ³ã‚«ãƒ¼ã®åŠ¹æœ</strong>
                    <div style="margin-top: 5px; font-size: 12px; line-height: 1.6;">
                        <div>Phase0å¹…: <span id="evalPhase0Width">-</span>px</div>
                        <div>Phase1å¹…(èª¿æ•´å‰): <span id="evalPhase1WidthBefore">-</span>px</div>
                        <div>Phase1å¹…(èª¿æ•´å¾Œ): <span id="evalPhase1WidthAfter">-</span>px</div>
                        <div>å¹…ã®å·®åˆ†: <span id="evalWidthDelta">-</span>px</div>
                        <div>1ã‚®ãƒ£ãƒƒãƒ—ã‚ãŸã‚Šã®èª¿æ•´: <span id="evalAdjustPerGap">-</span>px</div>
                        <div>å¹…ã‚¢ãƒ³ã‚«ãƒ¼é©ç”¨: <span id="evalWidthAnchorApplied">-</span></div>
                    </div>
                </div>
                <div class="info-item">
                    <strong>Phase0ã¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰åŠ¹æœ</strong>
                    <div style="margin-top: 5px; font-size: 12px; line-height: 1.6;">
                        <div>ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡: <span id="evalBlendRatio">-</span>%</div>
                        <div>å¹³å‡Phase0ã‚®ãƒ£ãƒƒãƒ—: <span id="evalAvgPhase0Gap">-</span>px</div>
                        <div>å¹³å‡Phase1ã‚®ãƒ£ãƒƒãƒ—: <span id="evalAvgPhase1Gap">-</span>px</div>
                        <div>å¹³å‡ãƒ–ãƒ¬ãƒ³ãƒ‰å¾Œã‚®ãƒ£ãƒƒãƒ—: <span id="evalAvgBlendedGap">-</span>px</div>
                        <div>ã‚®ãƒ£ãƒƒãƒ—å¤‰åŒ–ç‡: <span id="evalGapChangeRate">-</span>%</div>
                    </div>
                </div>
                <div class="info-item">
                    <strong>ç·åˆè©•ä¾¡</strong>
                    <div style="margin-top: 5px; font-size: 12px; line-height: 1.6;">
                        <div>å­¦ç¿’æ¸ˆã¿ãƒšã‚¢æ•°: <span id="evalLearnedPairs">-</span> / <span id="evalTotalPairs">-</span></div>
                        <div>æœªå­¦ç¿’ãƒšã‚¢æ•°: <span id="evalUnlearnedPairs">-</span></div>
                        <div>ã‚®ãƒ£ãƒƒãƒ—ã®æ¨™æº–åå·®: <span id="evalGapStdDev">-</span>px</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // Phase0/Phase1 ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…
        // ============================================
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹
        let phaseMode = "phase0";  // "phase0" or "phase1" or "compare"
        let phase1Model = null;   // Phase1ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
        let phase1ModelAverage = null;  // å­¦ç¿’æ¸ˆã¿ãƒšã‚¢ã®gap_norm_avgã®å¹³å‡å€¤ï¼ˆæœªå­¦ç¿’ãƒšã‚¢ç”¨ï¼‰
        let phase0Average = null;  // Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã§è¨ˆç®—ã—ãŸå¹³å‡å€¤ï¼ˆä¿‚æ•°è¨ˆç®—ç”¨ï¼‰
        let unlearnedPairAlgorithm = "average";  // æœªå­¦ç¿’ãƒšã‚¢ã®å‡¦ç†æ–¹æ³•: "average", "phase0", "phase0_scaled"
        let showUnlearnedPairs = false;  // æœªå­¦ç¿’ãƒšã‚¢ã®å¯è¦–åŒ–ã‚’è¡¨ç¤ºã™ã‚‹ã‹ã©ã†ã‹
        let currentTextInfo = null;  // ç¾åœ¨ã®æ–‡å­—åˆ—å…¨ä½“ã®æƒ…å ±ï¼ˆæ–‡å­—åˆ—å…¨ä½“ã®å¹…è¨ˆç®—ç”¨ï¼‰
        let isComputingPhase0Width = false;  // Phase0ã®å¹…è¨ˆç®—ä¸­ãƒ•ãƒ©ã‚°ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ç”¨ï¼‰
        let blendRatio = 0.0;  // Phase0ã¨Phase1ã®ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ï¼ˆ0.0 = Phase0ã®ã¿ã€1.0 = Phase1ã®ã¿ã€0.5 = 50%ãšã¤ï¼‰

        // ä¸€èˆ¬çš„ãªãƒ•ã‚©ãƒ³ãƒˆãƒªã‚¹ãƒˆï¼ˆæ—¥æœ¬èªãƒ»è‹±èªï¼‰
        const commonFonts = [
            // æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆï¼ˆæ˜æœç³»ï¼‰
            "æ¸¸æ˜æœ", "Yu Mincho", "æ¸¸æ˜æœä½“",
            "ãƒ’ãƒ©ã‚®ãƒæ˜æœ ProN", "Hiragino Mincho ProN", "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro", "Hiragino Mincho Pro",
            "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro W3", "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro W6",
            "æ˜æœä½“", "MS Mincho", "MS æ˜æœ",
            "å°å¡šæ˜æœ Pro", "Kozuka Mincho Pro",
            "ãƒªãƒ¥ã‚¦ãƒŸãƒ³", "Ryumin",
            "ç­‘ç´«æ˜æœ", "Tsukushi Mincho",
            "æºãƒæ˜æœ", "Source Han Serif", "Noto Serif CJK JP",
            "08ä¸¸ä¸‰-æ˜æœä½“",
            
            // æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆï¼ˆã‚´ã‚·ãƒƒã‚¯ç³»ï¼‰
            "æ¸¸ã‚´ã‚·ãƒƒã‚¯", "Yu Gothic", "æ¸¸ã‚´ã‚·ãƒƒã‚¯ä½“",
            "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ ProN", "Hiragino Kaku Gothic ProN", "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro", "Hiragino Kaku Gothic Pro",
            "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro W3", "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro W6",
            "ãƒ¡ã‚¤ãƒªã‚ª", "Meiryo",
            "MS ã‚´ã‚·ãƒƒã‚¯", "MS Gothic",
            "å°å¡šã‚´ã‚·ãƒƒã‚¯ Pro", "Kozuka Gothic Pro",
            "æ–°ã‚´", "Shin Go",
            "æºãƒè§’ã‚´ã‚·ãƒƒã‚¯", "Source Han Sans", "Noto Sans CJK JP",
            "UD ãƒ‡ã‚¸ã‚¿ãƒ« æ•™ç§‘æ›¸ä½“", "UD Digi Kyokasho",
            "BIZ UDã‚´ã‚·ãƒƒã‚¯", "BIZ UD Gothic",
            "BIZ UDPã‚´ã‚·ãƒƒã‚¯", "BIZ UDP Gothic",
            
            // æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆï¼ˆä¸¸ã‚´ã‚·ãƒƒã‚¯ç³»ï¼‰
            "ä¸¸ã‚´ã‚·ãƒƒã‚¯", "Maru Gothic",
            "ãƒ’ãƒ©ã‚®ãƒä¸¸ã‚´ ProN", "Hiragino Maru Gothic ProN",
            "å°å¡šä¸¸ã‚´ã‚·ãƒƒã‚¯ Pro", "Kozuka Maru Gothic Pro",
            "UD ãƒ‡ã‚¸ã‚¿ãƒ« æ•™ç§‘æ›¸ä½“ NK-R", "UD Digi Kyokasho NK-R",
            
            // è‹±èªãƒ•ã‚©ãƒ³ãƒˆï¼ˆã‚»ãƒªãƒ•ï¼‰
            "Times New Roman", "Times",
            "Georgia", "Palatino", "Book Antiqua",
            "Garamond", "Baskerville", "Caslon",
            
            // è‹±èªãƒ•ã‚©ãƒ³ãƒˆï¼ˆã‚µãƒ³ã‚»ãƒªãƒ•ï¼‰
            "Arial", "Helvetica", "Helvetica Neue",
            "Verdana", "Tahoma", "Trebuchet MS",
            "Calibri", "Segoe UI", "Roboto",
            "Open Sans", "Lato", "Montserrat",
            
            // è‹±èªãƒ•ã‚©ãƒ³ãƒˆï¼ˆç­‰å¹…ï¼‰
            "Courier New", "Courier", "Monaco",
            "Consolas", "Menlo", "Lucida Console",
            
            // è‹±èªãƒ•ã‚©ãƒ³ãƒˆï¼ˆè£…é£¾ãƒ»ãã®ä»–ï¼‰
            "Century Gothic", "Futura", "Gill Sans",
            
            // è£…é£¾ç³»ãƒ»ãƒ­ã‚´é¢¨ãƒ•ã‚©ãƒ³ãƒˆï¼ˆDesignï¼‰
            "Comic Sans MS", "Impact", "Arial Black",
            "Cooper Black", "Bauhaus 93", "Stencil",
            "Algerian", "Broadway", "Chiller",
            "Copperplate Gothic", "Engravers MT", "Felix Titling",
            "Harrington", "Hobo Std", "Informal Roman",
            "Lithos Pro", "Niagara Engraved", "Niagara Solid",
            "OCR A Extended", "Old English Text MT", "Onyx",
            "Papyrus", "Playbill", "Ravie",
            "Showcard Gothic", "Snap ITC", "Stencil Std",
            "Wide Latin", "Wingdings", "Webdings",
            
            // ç­†è¨˜ä½“ãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆç³»ãƒ•ã‚©ãƒ³ãƒˆï¼ˆæ—¥æœ¬èªï¼‰
            "HGè¡Œæ›¸ä½“", "HG Gyoshotai",
            "HGæ­£æ¥·æ›¸ä½“-PRO", "HG Seikaishotai PRO",
            "HGæ•™ç§‘æ›¸ä½“", "HG Kyokashotai",
            "DFè¡Œæ›¸ä½“", "DF Gyoshotai",
            "DFä¸­è¡Œæ›¸ä½“", "DF Chu Gyoshotai",
            "DFå¤ªè¡Œæ›¸ä½“", "DF Futo Gyoshotai",
            "DFä¸­å¤ªæ¥·æ›¸ä½“", "DF Chuto Kaishotai",
            "DFå¤ªæ¥·æ›¸ä½“", "DF Futo Kaishotai",
            "DFä¸­æ¥·æ›¸ä½“", "DF Chu Kaishotai",
            "DFPOPè¡Œæ›¸ä½“", "DFPOP Gyoshotai",
            "DFPOPæ¥·æ›¸ä½“", "DFPOP Kaishotai",
            "DFPOPæ¯›ç­†ä½“", "DFPOP Mofutai",
            "DFPOPå‹˜äº­æµ", "DFPOP Kanteiryu",
            "DFPOPå‹˜æµ", "DFPOP Kanryu",
            "DFPOPæ±Ÿæˆ¸å‹˜äº­æµ", "DFPOP Edo Kanteiryu",
            "DFPOPæ±Ÿæˆ¸æ–‡å­—", "DFPOP Edomoji",
            "DFPOPç›¸æ’²æ–‡å­—", "DFPOP Sumomoji",
            "DFPOPå¯„å¸­æ–‡å­—", "DFPOP Yose Moji",
            "DFPOPç± æ–‡å­—", "DFPOP Kagomoji",
            "DFPOPç¯†æ›¸ä½“", "DFPOP Tenshotai",
            "DFPOPéš·æ›¸ä½“", "DFPOP Reishotai",
            "DFPOPå¤å°ä½“", "DFPOP Kointai",
            "HGPå‰µè‹±è§’ï¾ï¾Ÿï½¯ï¾Œï¾Ÿä½“", "HGP Soei Kakupopu",
            "HGSå‰µè‹±è§’ï¾ï¾Ÿï½¯ï¾Œï¾Ÿä½“", "HGS Soei Kakupopu",
            "HGå‰µè‹±è§’ï¾ï¾Ÿï½¯ï¾Œï¾Ÿä½“", "HG Soei Kakupopu",
            
            // ç­†è¨˜ä½“ãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆç³»ãƒ•ã‚©ãƒ³ãƒˆï¼ˆè‹±èªï¼‰
            "Brush Script MT", "Brush Script",
            "Lucida Handwriting", "Lucida Calligraphy",
            "Monotype Corsiva", "Corsiva",
            "Script MT Bold", "Script",
            "Vivaldi", "Edwardian Script ITC",
            "French Script MT", "French Script",
            "Kunstler Script", "Kunstler",
            "Mistral", "Lucida Blackletter",
            "Old English Text MT", "Old English",
            "Blackadder ITC", "Blackadder",
            "Bradley Hand ITC", "Bradley Hand",
            "Freestyle Script", "Freestyle",
            "Gigi", "Harlow Solid Italic",
            "Jokerman", "Juice ITC",
            "Kristen ITC", "Kristen",
            "Magneto", "Matura MT Script Capitals",
            "Rage Italic", "Rage",
            "Segoe Script", "Segoe Print",
            "Tempus Sans ITC", "Tempus Sans",
            "Viner Hand ITC", "Viner Hand",
            "Zapfino", "Zapf Chancery",
        ];

        // 2.1 ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼åˆ†é¡ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆæ‹¡å¼µç‰ˆï¼‰ 
        const fontFamilyMap = {
            // æ˜æœç³»
            "æ¸¸æ˜æœ": "Mincho", "Yu Mincho": "Mincho", "æ¸¸æ˜æœä½“": "Mincho",
            "ãƒ’ãƒ©ã‚®ãƒæ˜æœ ProN": "Mincho", "Hiragino Mincho ProN": "Mincho",
            "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro": "Mincho", "Hiragino Mincho Pro": "Mincho",
            "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro W3": "Mincho", "ãƒ’ãƒ©ã‚®ãƒæ˜æœ Pro W6": "Mincho",
            "æ˜æœä½“": "Mincho", "MS Mincho": "Mincho", "MS æ˜æœ": "Mincho",
            "å°å¡šæ˜æœ Pro": "Mincho", "Kozuka Mincho Pro": "Mincho",
            "ãƒªãƒ¥ã‚¦ãƒŸãƒ³": "Mincho", "Ryumin": "Mincho",
            "ç­‘ç´«æ˜æœ": "Mincho", "Tsukushi Mincho": "Mincho",
            "æºãƒæ˜æœ": "Mincho", "Source Han Serif": "Mincho", "Noto Serif CJK JP": "Mincho",
            "08ä¸¸ä¸‰-æ˜æœä½“": "Mincho",
            "08ä¸¸ä¸‰ãƒ¼æ˜æœä½“": "Mincho",  // é•·éŸ³ç¬¦ç‰ˆã‚‚è¿½åŠ 
            "08ä¸¸ä¸‰ï¼æ˜æœä½“": "Mincho",  // å…¨è§’ãƒã‚¤ãƒ•ãƒ³ç‰ˆã‚‚è¿½åŠ 
            
            // ã‚´ã‚·ãƒƒã‚¯ç³»
            "æ¸¸ã‚´ã‚·ãƒƒã‚¯": "Gothic", "Yu Gothic": "Gothic", "æ¸¸ã‚´ã‚·ãƒƒã‚¯ä½“": "Gothic",
            "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ ProN": "Gothic", "Hiragino Kaku Gothic ProN": "Gothic",
            "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro": "Gothic", "Hiragino Kaku Gothic Pro": "Gothic",
            "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro W3": "Gothic", "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro W6": "Gothic",
            "ãƒ¡ã‚¤ãƒªã‚ª": "Gothic", "Meiryo": "Gothic",
            "MS ã‚´ã‚·ãƒƒã‚¯": "Gothic", "MS Gothic": "Gothic",
            "å°å¡šã‚´ã‚·ãƒƒã‚¯ Pro": "Gothic", "Kozuka Gothic Pro": "Gothic",
            "æ–°ã‚´": "Gothic", "Shin Go": "Gothic",
            "æºãƒè§’ã‚´ã‚·ãƒƒã‚¯": "Gothic", "Source Han Sans": "Gothic", "Noto Sans CJK JP": "Gothic",
            "UD ãƒ‡ã‚¸ã‚¿ãƒ« æ•™ç§‘æ›¸ä½“": "Gothic", "UD Digi Kyokasho": "Gothic",
            "BIZ UDã‚´ã‚·ãƒƒã‚¯": "Gothic", "BIZ UD Gothic": "Gothic",
            "BIZ UDPã‚´ã‚·ãƒƒã‚¯": "Gothic", "BIZ UDP Gothic": "Gothic",
            "Arial": "Gothic", "Helvetica": "Gothic", "Helvetica Neue": "Gothic",
            "Verdana": "Gothic", "Tahoma": "Gothic", "Trebuchet MS": "Gothic",
            "Calibri": "Gothic", "Segoe UI": "Gothic", "Roboto": "Gothic",
            "Open Sans": "Gothic", "Lato": "Gothic", "Montserrat": "Gothic",
            
            // ä¸¸ã‚´ã‚·ãƒƒã‚¯ç³»
            "ä¸¸ã‚´ã‚·ãƒƒã‚¯": "MaruGothic", "Maru Gothic": "MaruGothic",
            "ãƒ’ãƒ©ã‚®ãƒä¸¸ã‚´ ProN": "MaruGothic", "Hiragino Maru Gothic ProN": "MaruGothic",
            "å°å¡šä¸¸ã‚´ã‚·ãƒƒã‚¯ Pro": "MaruGothic", "Kozuka Maru Gothic Pro": "MaruGothic",
            "UD ãƒ‡ã‚¸ã‚¿ãƒ« æ•™ç§‘æ›¸ä½“ NK-R": "MaruGothic", "UD Digi Kyokasho NK-R": "MaruGothic",
            
            // ç­†è¨˜ä½“ãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆç³»ï¼ˆBrushï¼‰
            "HGè¡Œæ›¸ä½“": "Brush", "HG Gyoshotai": "Brush",
            "HGæ­£æ¥·æ›¸ä½“-PRO": "Brush", "HG Seikaishotai PRO": "Brush",
            "DFè¡Œæ›¸ä½“": "Brush", "DF Gyoshotai": "Brush",
            "DFä¸­è¡Œæ›¸ä½“": "Brush", "DF Chu Gyoshotai": "Brush",
            "DFå¤ªè¡Œæ›¸ä½“": "Brush", "DF Futo Gyoshotai": "Brush",
            "DFä¸­å¤ªæ¥·æ›¸ä½“": "Brush", "DF Chuto Kaishotai": "Brush",
            "DFå¤ªæ¥·æ›¸ä½“": "Brush", "DF Futo Kaishotai": "Brush",
            "DFä¸­æ¥·æ›¸ä½“": "Brush", "DF Chu Kaishotai": "Brush",
            "DFPOPè¡Œæ›¸ä½“": "Brush", "DFPOP Gyoshotai": "Brush",
            "DFPOPæ¥·æ›¸ä½“": "Brush", "DFPOP Kaishotai": "Brush",
            "DFPOPæ¯›ç­†ä½“": "Brush", "DFPOP Mofutai": "Brush",
            "DFPOPå‹˜äº­æµ": "Brush", "DFPOP Kanteiryu": "Brush",
            "DFPOPå‹˜æµ": "Brush", "DFPOP Kanryu": "Brush",
            "DFPOPæ±Ÿæˆ¸å‹˜äº­æµ": "Brush", "DFPOP Edo Kanteiryu": "Brush",
            "DFPOPæ±Ÿæˆ¸æ–‡å­—": "Brush", "DFPOP Edomoji": "Brush",
            "DFPOPç›¸æ’²æ–‡å­—": "Brush", "DFPOP Sumomoji": "Brush",
            "DFPOPå¯„å¸­æ–‡å­—": "Brush", "DFPOP Yose Moji": "Brush",
            "DFPOPç± æ–‡å­—": "Brush", "DFPOP Kagomoji": "Brush",
            "DFPOPç¯†æ›¸ä½“": "Brush", "DFPOP Tenshotai": "Brush",
            "DFPOPéš·æ›¸ä½“": "Brush", "DFPOP Reishotai": "Brush",
            "DFPOPå¤å°ä½“": "Brush", "DFPOP Kointai": "Brush",
            
            // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆç­†è¨˜ä½“ãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆç³»ï¼ˆScriptï¼‰
            "Brush Script MT": "Script", "Brush Script": "Script",
            "Lucida Handwriting": "Script", "Lucida Calligraphy": "Script",
            "Monotype Corsiva": "Script", "Corsiva": "Script",
            "Script MT Bold": "Script", "Script": "Script",
            "Vivaldi": "Script", "Edwardian Script ITC": "Script",
            "French Script MT": "Script", "French Script": "Script",
            "Kunstler Script": "Script", "Kunstler": "Script",
            "Mistral": "Script", "Lucida Blackletter": "Script",
            "Old English Text MT": "Script", "Old English": "Script",
            "Blackadder ITC": "Script", "Blackadder": "Script",
            "Bradley Hand ITC": "Script", "Bradley Hand": "Script",
            "Freestyle Script": "Script", "Freestyle": "Script",
            "Gigi": "Script", "Harlow Solid Italic": "Script",
            "Jokerman": "Script", "Juice ITC": "Script",
            "Kristen ITC": "Script", "Kristen": "Script",
            "Magneto": "Script", "Matura MT Script Capitals": "Script",
            "Rage Italic": "Script", "Rage": "Script",
            "Segoe Script": "Script", "Segoe Print": "Script",
            "Tempus Sans ITC": "Script", "Tempus Sans": "Script",
            "Viner Hand ITC": "Script", "Viner Hand": "Script",
            "Zapfino": "Script", "Zapf Chancery": "Script",
            
            // è£…é£¾ç³»ãƒ»ãƒ­ã‚´é¢¨ï¼ˆDesignï¼‰
            "Comic Sans MS": "Design", "Impact": "Design", "Arial Black": "Design",
            "Cooper Black": "Design", "Bauhaus 93": "Design", "Stencil": "Design",
            "Algerian": "Design", "Broadway": "Design", "Chiller": "Design",
            "Copperplate Gothic": "Design", "Engravers MT": "Design", "Felix Titling": "Design",
            "Harrington": "Design", "Hobo Std": "Design", "Informal Roman": "Design",
            "Lithos Pro": "Design", "Niagara Engraved": "Design", "Niagara Solid": "Design",
            "OCR A Extended": "Design", "Onyx": "Design",
            "Papyrus": "Design", "Playbill": "Design", "Ravie": "Design",
            "Showcard Gothic": "Design", "Snap ITC": "Design", "Stencil Std": "Design",
            "Wide Latin": "Design", "Wingdings": "Design", "Webdings": "Design",
        };

        // 2.2 ãƒ•ã‚¡ãƒŸãƒªãƒ¼åˆ¥ãƒ»ã‚¹ã‚¿ã‚¤ãƒ«åˆ¥ã®åŸºæœ¬ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
        const baseTracking = {
            Mincho: {
                default: 0,
                å’Œãƒ¢ãƒ€ãƒ³: -0.5,
                åŒ—æ¬§: +0.5,
                ãƒ¢ãƒ€ãƒ³: 0,
                ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«: 0,
            },
            Gothic: {
                default: 0,
                ãƒ¢ãƒ€ãƒ³: -0.3,
                ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«: +0.3,
                å’Œãƒ¢ãƒ€ãƒ³: 0,
                åŒ—æ¬§: 0,
            },
            MaruGothic: {
                default: 0,
            },
            Brush: {
                default: -0.8,
            },
            Script: {
                default: -0.5,
            },
            Design: {
                default: 0,
            },
        };

        // ============================================
        // æ–‡å­—ç‰¹å¾´åˆ†é¡ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆCharFeatureResolverï¼‰
        // ============================================

        // ç‰¹å¾´é‡ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const featureCache = {};

        // æ–‡å­—ç¨®ã‚’åˆ¤å®šï¼ˆUnicode/æ–‡å­—ç¨®ãƒ™ãƒ¼ã‚¹ï¼‰
        function getCharCategory(char) {
            const code = char.charCodeAt(0);
            
            // æ¼¢å­—ï¼ˆCJKçµ±åˆæ¼¢å­—ï¼‰
            if ((code >= 0x4E00 && code <= 0x9FFF) || 
                (code >= 0x3400 && code <= 0x4DBF) ||
                (code >= 0xF900 && code <= 0xFAFF)) {
                return "KANJI";
            }
            
            // ã²ã‚‰ãŒãª
            if (code >= 0x3040 && code <= 0x309F) {
                return "HIRAGANA";
            }
            
            // ã‚«ã‚¿ã‚«ãƒŠ
            if (code >= 0x30A0 && code <= 0x30FF) {
                return "KATAKANA";
            }
            
            // è‹±å¤§æ–‡å­—
            if (code >= 0x41 && code <= 0x5A) {
                return "LATIN_UPPER";
            }
            
            // è‹±å°æ–‡å­—
            if (code >= 0x61 && code <= 0x7A) {
                return "LATIN_LOWER";
            }
            
            // è¨˜å·ãƒ»ãã®ä»–
            return "SYMBOL";
        }

        // Canvasã‹ã‚‰æ–‡å­—ã®å½¢çŠ¶ã‚’åˆ†æ
        function analyzeCharWithCanvas(char, fontId, fontSize) {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // ãƒ•ã‚©ãƒ³ãƒˆã‚’è¨­å®šï¼ˆãƒ•ã‚©ãƒ³ãƒˆåã«ãƒã‚¤ãƒ•ãƒ³ã‚„ã‚¹ãƒšãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆã¯å¼•ç”¨ç¬¦ã§å›²ã‚€ï¼‰
                ctx.font = `${fontSize}px "${fontId}"`;
                
                // ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’å–å¾—
                const metrics = ctx.measureText(char);
                const width = metrics.width;
                
                // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å–å¾—ï¼ˆåˆ©ç”¨å¯èƒ½ãªå ´åˆï¼‰
                const actualBoundingBoxAscent = metrics.actualBoundingBoxAscent || fontSize * 0.8;
                const actualBoundingBoxDescent = metrics.actualBoundingBoxDescent || fontSize * 0.2;
                const actualBoundingBoxLeft = metrics.actualBoundingBoxLeft || 0;
                const actualBoundingBoxRight = metrics.actualBoundingBoxRight || width;
                
                const height = actualBoundingBoxAscent + actualBoundingBoxDescent;
                const fullWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
                
                // Canvasã‚µã‚¤ã‚ºã‚’è¨­å®šï¼ˆä½™ç™½ã‚’å«ã‚€ï¼‰
                const padding = Math.max(fontSize * 0.2, 5);
                const baselineX = padding - actualBoundingBoxLeft;
                canvas.width = Math.ceil(fullWidth + padding * 2);
                canvas.height = Math.ceil(height + padding * 2);
                
                // èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã—
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // æ–‡å­—ã‚’æç”»
                ctx.font = `${fontSize}px "${fontId}"`;
                ctx.fillStyle = '#000000';
                ctx.textBaseline = 'alphabetic';
                ctx.textAlign = 'left';
                
                // æç”»ä½ç½®ã‚’è¨ˆç®—ï¼ˆå·¦ã®ä½™ç™½ã¨ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ä½ç½®ã‚’è€ƒæ…®ï¼‰
                const x = padding - actualBoundingBoxLeft;
                const y = padding + actualBoundingBoxAscent;
                ctx.fillText(char, x, y);
                
                // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // æ–‡å­—ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹é ˜åŸŸã‚’è¨ˆç®—ï¼ˆä½™ç™½ã‚’é™¤ãï¼‰
                const textLeft = Math.max(0, Math.floor(padding - actualBoundingBoxLeft));
                const textTop = Math.max(0, Math.floor(padding));
                const textRight = Math.min(canvas.width, Math.floor(padding - actualBoundingBoxLeft + fullWidth));
                const textBottom = Math.min(canvas.height, Math.floor(padding + height));
                
                let inkLeft = -actualBoundingBoxLeft;
                let inkRight = actualBoundingBoxRight;
                
                // æœ‰åŠ¹ãªé ˜åŸŸã‹ãƒã‚§ãƒƒã‚¯
                if (textRight <= textLeft || textBottom <= textTop) {
                    // ç„¡åŠ¹ãªé ˜åŸŸã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
                    return {
                        width,
                        height,
                        fillRatio: 0.4,
                        aspectRatio: width / height,
                        inkLeft,
                        inkRight
                    };
                }
                
                // ã¾ãšã€å®Ÿéš›ã«æç”»ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã®ç¯„å›²ã‚’æ¤œå‡º
                let minY = textBottom;
                let maxY = textTop;
                let minX = textRight;
                let maxX = textLeft;
                
                // æœ€åˆã®ãƒ‘ã‚¹ï¼šå®Ÿéš›ã«æç”»ã•ã‚ŒãŸé»’ãƒ”ã‚¯ã‚»ãƒ«ã®ç¯„å›²ã‚’æ¤œå‡º
                for (let y = textTop; y < textBottom; y++) {
                    for (let x = textLeft; x < textRight; x++) {
                        const index = (y * canvas.width + x) * 4;
                        if (index + 3 < data.length) {
                            const r = data[index];
                            const g = data[index + 1];
                            const b = data[index + 2];
                            const a = data[index + 3];
                            
                            // é»’ã£ã½ã„ãƒ”ã‚¯ã‚»ãƒ«ã‚’åˆ¤å®šï¼ˆé–¾å€¤: RGBå¹³å‡ < 200ã€ã‚ˆã‚Šç·©ã„åˆ¤å®šï¼‰
                            const gray = (r + g + b) / 3;
                            if (gray < 200 && a > 100) {
                                // å®Ÿéš›ã«æç”»ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã®ç¯„å›²ã‚’æ›´æ–°
                                if (y < minY) minY = y;
                                if (y > maxY) maxY = y;
                                if (x < minX) minX = x;
                                if (x > maxX) maxX = x;
                            }
                        }
                    }
                }
                
                // å®Ÿéš›ã«æç”»ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã®ç¯„å›²ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
                if (maxY < minY || maxX < minX) {
                    // é»’ãƒ”ã‚¯ã‚»ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
                    return {
                        width,
                        height,
                        fillRatio: 0.4,
                        aspectRatio: width / height,
                        inkLeft,
                        inkRight
                    };
                }
                
                // é»’å¯†åº¦ã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã«æç”»ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã®ç¯„å›²å†…ã®ã¿ã‚’å¯¾è±¡ï¼‰
                let filledPixels = 0;
                let totalPixels = 0;
                
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        const index = (y * canvas.width + x) * 4;
                        if (index + 3 < data.length) {
                            const r = data[index];
                            const g = data[index + 1];
                            const b = data[index + 2];
                            const a = data[index + 3];
                            
                            // é»’ã£ã½ã„ãƒ”ã‚¯ã‚»ãƒ«ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆé–¾å€¤: RGBå¹³å‡ < 200ã€ã‚ˆã‚Šç·©ã„åˆ¤å®šï¼‰
                            const gray = (r + g + b) / 3;
                            if (gray < 200 && a > 100) {
                                filledPixels++;
                            }
                            totalPixels++;
                        }
                    }
                }
                
                // å®Ÿéš›ã«æç”»ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã®ç¯„å›²å†…ã§ã®fillRatioã‚’è¨ˆç®—
                const fillRatio = totalPixels > 0 ? filledPixels / totalPixels : 0.4;
                
                // å®Ÿéš›ã«æç”»ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã®ç¯„å›²ã‹ã‚‰é«˜ã•ã¨å¹…ã‚’è¨ˆç®—
                inkLeft = minX - baselineX;
                inkRight = maxX - baselineX;
                
                const actualHeight = (maxY >= minY) ? (maxY - minY + 1) : height;
                const actualWidth = Math.max(1, inkRight - inkLeft);
                
                // ç¸¦æ¨ªæ¯”ã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã®æç”»é ˜åŸŸã‚’ä½¿ç”¨ï¼‰
                const aspectRatio = actualWidth / actualHeight;
                
                return {
                    width: actualWidth, // å®Ÿéš›ã®æç”»é ˜åŸŸã®å¹…ã‚’ä½¿ç”¨
                    height: actualHeight, // å®Ÿéš›ã®æç”»é ˜åŸŸã®é«˜ã•ã‚’ä½¿ç”¨
                    fillRatio,
                    aspectRatio,
                    inkLeft,
                    inkRight
                };
            } catch (e) {
                console.error('æ–‡å­—å½¢çŠ¶åˆ†æã‚¨ãƒ©ãƒ¼:', e, char, fontId);
                // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
                try {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.font = `${fontSize}px "${fontId}"`;
                    const metrics = tempCtx.measureText(char);
                    return {
                        width: metrics.width,
                        height: fontSize,
                        fillRatio: 0.4,
                        aspectRatio: metrics.width / fontSize,
                        inkLeft: 0,
                        inkRight: metrics.width
                    };
                } catch (e2) {
                    // ã•ã‚‰ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯æœ€å°é™ã®å€¤ã‚’è¿”ã™
                    return {
                        width: fontSize * 0.6,
                        height: fontSize,
                        fillRatio: 0.4,
                        aspectRatio: 0.6,
                        inkLeft: 0,
                        inkRight: fontSize * 0.6
                    };
                }
            }
        }

        // æ–‡å­—ã®ç‰¹å¾´é‡ã‚’è‡ªå‹•åˆ¤å®š
        function resolveCharFeatures(char, fontId, fontSize) {
            try {
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼
                const cacheKey = `${fontId}:${char}:${fontSize}`;
                
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚§ãƒƒã‚¯
                if (featureCache[cacheKey]) {
                    return featureCache[cacheKey];
                }
                
                // æ–‡å­—ç¨®ã‚’åˆ¤å®š
                const charCategory = getCharCategory(char);
                
                // Canvasã‹ã‚‰å½¢çŠ¶ã‚’åˆ†æ
                const shape = analyzeCharWithCanvas(char, fontId, fontSize);
                
                // shapeãŒæ­£ã—ãå–å¾—ã§ãã¦ã„ã‚‹ã‹ç¢ºèª
                if (!shape || typeof shape.width === 'undefined') {
                    throw new Error('å½¢çŠ¶åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                // Canvas APIã®actualBoundingBoxã‚’å–å¾—ï¼ˆSVGã®bboxã¨ã®æ¯”è¼ƒç”¨ï¼‰
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.font = `${fontSize}px "${fontId}"`;
                const metrics = ctx.measureText(char);
                // actualBoundingBoxLeftã¯é€šå¸¸0ã¾ãŸã¯è² ã®å€¤ï¼ˆæ–‡å­—ãŒãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã®å·¦å´ã«åºƒãŒã£ã¦ã„ã‚‹å ´åˆï¼‰
                const actualBoundingBoxLeft = metrics.actualBoundingBoxLeft || 0;
                // actualBoundingBoxRightã¯é€šå¸¸widthä»¥ä¸Šï¼ˆæ–‡å­—ãŒãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã®å³å´ã«åºƒãŒã£ã¦ã„ã‚‹å ´åˆï¼‰
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯metrics.widthã‚’ä½¿ç”¨ï¼ˆshape.widthã¯å®Ÿéš›ã®æç”»é ˜åŸŸã®å¹…ã§ã€ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã«è¿‘ã„å€¤ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ï¼‰
                const actualBoundingBoxRight = metrics.actualBoundingBoxRight !== undefined 
                    ? metrics.actualBoundingBoxRight 
                    : metrics.width;
            
            // é»’å¯†åº¦ã‚’åˆ¤å®š
            let density;
            if (shape.fillRatio > 0.45) {
                density = "HEAVY";
            } else if (shape.fillRatio < 0.20) {
                density = "LIGHT";
            } else {
                density = "MEDIUM";
            }
            
            // æ–‡å­—ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            let charType;
            
            if (charCategory === "KANJI") {
                // æ¼¢å­—ã®å ´åˆ
                if (shape.aspectRatio < 0.7) {
                    // ç¸¦é•·
                    charType = density === "HEAVY" ? "VERTICAL_HEAVY" : "VERTICAL_LIGHT";
                } else if (shape.fillRatio > 0.5) {
                    // é»’å¯†åº¦ãŒé«˜ã„
                    charType = "COMPLEX";
                } else {
                    charType = "COMPLEX";
                }
            } else if (charCategory === "HIRAGANA" || charCategory === "KATAKANA") {
                // ã‹ãªã®å ´åˆ
                if (shape.fillRatio < 0.3 && shape.aspectRatio > 0.8 && shape.aspectRatio < 1.25) {
                    charType = "CURVE";
                } else if (shape.aspectRatio > 1.3 || shape.aspectRatio < 0.6) {
                    // æ–œã‚ç·šãŒå¤šã„å¯èƒ½æ€§
                    charType = "DIAGONAL";
                } else {
                    charType = "KANA";
                }
            } else if (charCategory === "LATIN_UPPER") {
                charType = "LATIN_UPPER";
            } else if (charCategory === "LATIN_LOWER") {
                charType = "LATIN_LOWER";
            } else {
                // ãã®ä»–ï¼ˆè¨˜å·ãªã©ï¼‰
                if (shape.fillRatio > 0.6) {
                    charType = "CURVE";
                } else {
                    charType = "MIXED";
                }
            }
            
                // çµæœã‚’æ§‹ç¯‰
                const features = {
                    width: shape.width,
                    height: shape.height,
                    fillRatio: shape.fillRatio,
                    aspectRatio: shape.aspectRatio,
                    charType,
                    density,
                    charCategory,
                    // SVGã®bboxã¨ã®æ¯”è¼ƒç”¨ã«actualBoundingBoxã‚’è¿½åŠ 
                    actualBoundingBoxLeft: actualBoundingBoxLeft,
                    actualBoundingBoxRight: actualBoundingBoxRight,
                    // å®Ÿéš›ã®æç”»å¹…ï¼ˆå·¦ç«¯ã‹ã‚‰å³ç«¯ã¾ã§ï¼‰
                    actualWidth: actualBoundingBoxRight - actualBoundingBoxLeft,
                    inkLeft: shape.inkLeft,
                    inkRight: shape.inkRight
                };
                
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
                featureCache[cacheKey] = features;
                
                return features;
            } catch (e) {
                console.error('æ–‡å­—ç‰¹å¾´é‡åˆ¤å®šã‚¨ãƒ©ãƒ¼:', e, char, fontId);
                // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
                const charCategory = getCharCategory(char);
                const defaultFeatures = {
                    width: fontSize * 0.6,
                    height: fontSize,
                    fillRatio: 0.4,
                    aspectRatio: 0.6,
                    charType: charCategory === "KANJI" ? "COMPLEX" : "MIXED",
                    density: "MEDIUM",
                    charCategory,
                    actualBoundingBoxLeft: 0,
                    actualBoundingBoxRight: fontSize * 0.6,
                    actualWidth: fontSize * 0.6,
                    inkLeft: 0,
                    inkRight: fontSize * 0.6
                };
                return defaultFeatures;
            }
        }

        // 5.1 ãƒšã‚¢ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®è£œæ­£å€¤
        const pairCategoryAdjust = {
            VERTICAL_VERTICAL: +0.4,
            VERTICAL_CURVE: +0.1,
            CURVE_CURVE: -0.2,
            DIAGONAL_ANY: -0.5,
            COMPLEX_COMPLEX: +0.6,
            LATIN_PAIR: -0.3,
            MIXED: 0.0,
        };

        // 5.2 é»’å¯†åº¦ã®çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚‹è£œæ­£
        const densityAdjust = {
            "HEAVY-HEAVY": +0.5,
            "HEAVY-MEDIUM": +0.3,
            "HEAVY-LIGHT": +0.2,
            "MEDIUM-MEDIUM": 0.0,
            "MEDIUM-LIGHT": -0.1,
            "LIGHT-LIGHT": -0.2,
            "MEDIUM-HEAVY": +0.3,
            "LIGHT-HEAVY": +0.2,
            "LIGHT-MEDIUM": -0.1,
        };

        // æ–‡å­—ã®ç‰¹å¾´é‡ã‚’å–å¾—ï¼ˆè‡ªå‹•åˆ¤å®šç‰ˆï¼‰
        function getCharFeatures(char, fontId, fontSize) {
            return resolveCharFeatures(char, fontId, fontSize);
        }

        // ãƒšã‚¢ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—
        function getPairCategory(typeA, typeB) {
            const isLatin = (type) => type === "LATIN_UPPER" || type === "LATIN_LOWER";
            const isDiagonal = (type) => type === "DIAGONAL";
            const isVertical = (type) => type === "VERTICAL_HEAVY" || type === "VERTICAL_LIGHT";
            const isCurve = (type) => type === "CURVE";
            const isComplex = (type) => type === "COMPLEX";

            if (isLatin(typeA) && isLatin(typeB)) return "LATIN_PAIR";
            if (isDiagonal(typeA) || isDiagonal(typeB)) return "DIAGONAL_ANY";
            if (isVertical(typeA) && isVertical(typeB)) return "VERTICAL_VERTICAL";
            if (isCurve(typeA) && isCurve(typeB)) return "CURVE_CURVE";
            if (isComplex(typeA) && isComplex(typeB)) return "COMPLEX_COMPLEX";
            if ((isVertical(typeA) && isCurve(typeB)) || (isCurve(typeA) && isVertical(typeB))) {
                return "VERTICAL_CURVE";
            }
            return "MIXED";
        }

        // ============================================
        // Phase1ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
        // ============================================
        // 
        // Phase1ãƒ¢ãƒ‡ãƒ«ã®æ§‹é€ :
        // {
        //   "ãƒ•ã‚©ãƒ³ãƒˆå": {  // ãƒ•ã‚©ãƒ³ãƒˆå›ºæœ‰ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ€å„ªå…ˆï¼‰
        //     "æ–‡å­—1|æ–‡å­—2": {
        //       "gap_norm_avg": ...,
        //       "gap_actual_avg": ...,
        //       "font_size_avg": ...,
        //       "count": ...
        //     }
        //   },
        //   "Mincho": {  // ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        //     "æ–‡å­—1|æ–‡å­—2": { ... }
        //   },
        //   "Gothic": { ... },
        //   "MaruGothic": { ... }
        // }
        // 
        // æ¤œç´¢å„ªå…ˆé †ä½:
        // 1. ãƒ•ã‚©ãƒ³ãƒˆåã§ç›´æ¥æ¤œç´¢ï¼ˆãƒ•ã‚©ãƒ³ãƒˆå›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ï¼‰
        // 2. é•·éŸ³ç¬¦ã‚’ãƒã‚¤ãƒ•ãƒ³ã«å¤‰æ›ã—ã¦æ¤œç´¢ï¼ˆè¡¨è¨˜æºã‚Œå¯¾å¿œï¼‰
        // 3. æ­£è¦åŒ–ã•ã‚ŒãŸã‚«ãƒ†ã‚´ãƒªã§æ¤œç´¢ï¼ˆã‚«ãƒ†ã‚´ãƒªã”ã¨ã®ãƒ‡ãƒ¼ã‚¿ï¼‰
        // 
        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆæ™‚ã®æ¨å¥¨äº‹é …:
        // - ãƒ•ã‚©ãƒ³ãƒˆå›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€ãƒ•ã‚©ãƒ³ãƒˆåã‚’ã‚­ãƒ¼ã¨ã—ã¦ä¿å­˜
        // - è¤‡æ•°ã®ãƒ•ã‚©ãƒ³ãƒˆã§å…±é€šã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€ã‚«ãƒ†ã‚´ãƒªåã‚’ã‚­ãƒ¼ã¨ã—ã¦ä¿å­˜
        // - ä¸¡æ–¹ä¿å­˜ã™ã‚‹ã“ã¨ã§ã€ãƒ•ã‚©ãƒ³ãƒˆå›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã§ã‚‚ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨å¯èƒ½
        
        async function loadPhase1Model() {
            try {
                const response = await fetch("/assets/phase1_model.json");
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                phase1Model = data;
                console.log("Phase1ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ", phase1Model);
                
                // ãƒ‡ãƒãƒƒã‚°: ãƒ¢ãƒ‡ãƒ«ã«å«ã¾ã‚Œã‚‹ã‚­ãƒ¼ã‚’è¡¨ç¤º
                const keys = Object.keys(phase1Model);
                const fontSpecificKeys = keys.filter(k => !["Mincho", "Gothic", "MaruGothic", "Brush", "Script", "Design"].includes(k));
                if (fontSpecificKeys.length > 0) {
                    console.log("ãƒ•ã‚©ãƒ³ãƒˆå›ºæœ‰ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿:", fontSpecificKeys);
                }
                
                // å­¦ç¿’æ¸ˆã¿ãƒšã‚¢ã®gap_norm_avgã®å¹³å‡å€¤ã‚’è¨ˆç®—ï¼ˆæœªå­¦ç¿’ãƒšã‚¢ç”¨ï¼‰
                let sumGapNorm = 0;
                let countGapNorm = 0;
                
                for (const fontKey in phase1Model) {
                    const fontData = phase1Model[fontKey];
                    if (typeof fontData !== 'object' || fontData === null) continue;
                    
                    for (const pairKey in fontData) {
                        const pairData = fontData[pairKey];
                        if (typeof pairData !== 'object' || pairData === null) continue;
                        
                        const gapNormAvg = pairData.gap_norm_avg;
                        if (gapNormAvg !== undefined && gapNormAvg !== null && typeof gapNormAvg === 'number') {
                            sumGapNorm += gapNormAvg;
                            countGapNorm++;
                        }
                    }
                }
                
                if (countGapNorm > 0) {
                    phase1ModelAverage = sumGapNorm / countGapNorm;
                    console.log(`å­¦ç¿’æ¸ˆã¿ãƒšã‚¢ã®å¹³å‡gap_norm_avg: ${phase1ModelAverage.toFixed(4)} (${countGapNorm}ãƒšã‚¢)`);
                } else {
                    phase1ModelAverage = null;
                    console.warn("å­¦ç¿’æ¸ˆã¿ãƒšã‚¢ã®å¹³å‡å€¤ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã§ã—ãŸ");
                }
                
                // Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã§è¨ˆç®—ã—ãŸå¹³å‡å€¤ã‚’æ¨å®šï¼ˆä¿‚æ•°è¨ˆç®—ç”¨ï¼‰
                // å­¦ç¿’æ¸ˆã¿ãƒšã‚¢ã¨åŒã˜ãƒšã‚¢ã«å¯¾ã—ã¦Phase0ã§è¨ˆç®—ã—ãŸå ´åˆã®å¹³å‡å€¤ã‚’è¨ˆç®—
                // å®Ÿéš›ã®ãƒšã‚¢ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦Phase0ã§è¨ˆç®—ã™ã‚‹ã®ã¯è¤‡é›‘ãªã®ã§ã€
                // ä¸€èˆ¬çš„ãªPhase0ã®gap_normå€¤ã‚’æ¨å®šï¼ˆbaseTracking + å¹³å‡çš„ãªè£œæ­£å€¤ï¼‰
                // ã“ã‚Œã¯æ¦‚ç®—å€¤ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹
                phase0Average = null;  // å¿…è¦ã«å¿œã˜ã¦å¾Œã§è¨ˆç®—
            } catch (error) {
                console.warn("Phase1ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:", error);
                console.warn("Phase0ãƒ¢ãƒ¼ãƒ‰ã®ã¿ã§å‹•ä½œã—ã¾ã™");
                phase1Model = null;
                phase1ModelAverage = null;
            }
        }
        
        // ============================================
        // ãƒ•ã‚©ãƒ³ãƒˆåæ­£è¦åŒ–é–¢æ•°
        // ============================================
        
        function normalizeFontName(fontName) {
            if (!fontName) return "Gothic";
            
            // fontFamilyMapã‚’ä½¿ç”¨ã—ã¦ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—
            const normalized = fontFamilyMap[fontName];
            if (normalized) {
                return normalized;
            }
            
            // é•·éŸ³ç¬¦ï¼ˆãƒ¼ï¼‰ã¨ãƒã‚¤ãƒ•ãƒ³ï¼ˆ-ï¼‰ã®é•ã„ã‚’è€ƒæ…®
            // ã€Œ08ä¸¸ä¸‰ãƒ¼æ˜æœä½“ã€ã¨ã€Œ08ä¸¸ä¸‰-æ˜æœä½“ã€ã®ä¸¡æ–¹ã«å¯¾å¿œ
            const normalizedName = fontName.replace(/ãƒ¼/g, '-').replace(/ï¼/g, '-');
            if (normalizedName !== fontName) {
                const normalizedFromMap = fontFamilyMap[normalizedName];
                if (normalizedFromMap) {
                    return normalizedFromMap;
                }
            }
            
            // éƒ¨åˆ†ä¸€è‡´ã§åˆ¤å®š
            const fontLower = fontName.toLowerCase();
            
            // æ˜æœç³»
            if (fontLower.includes("mincho") || fontLower.includes("æ˜æœ") || 
                fontLower.includes("serif") || fontLower.includes("times")) {
                return "Mincho";
            }
            
            // ä¸¸ã‚´ã‚·ãƒƒã‚¯ç³»
            if (fontLower.includes("maru") || fontLower.includes("ä¸¸") ||
                fontLower.includes("round")) {
                return "MaruGothic";
            }
            
            // ç­†è¨˜ä½“ãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆç³»
            if (fontLower.includes("brush") || fontLower.includes("script") ||
                fontLower.includes("è¡Œæ›¸") || fontLower.includes("æ¥·æ›¸") ||
                fontLower.includes("æ¯›ç­†") || fontLower.includes("å‹˜äº­æµ")) {
                return "Brush";
            }
            
            // è£…é£¾ç³»ãƒ»ãƒ­ã‚´é¢¨
            if (fontLower.includes("design") || fontLower.includes("impact") ||
                fontLower.includes("comic") || fontLower.includes("stencil")) {
                return "Design";
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯Gothic
            return "Gothic";
        }
        
        // ============================================
        // Phase0ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°é–¢æ•°
        // ============================================
        
        function getKerningPhase0(leftChar, rightChar, fontName, baseWidthPx, styleId = "default", globalTracking = 0) {
            // æ—¢å­˜ã®computeKerningPositionsãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨
            // 2æ–‡å­—ã®ãƒšã‚¢ã«å¯¾ã—ã¦ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å€¤ã‚’è¨ˆç®—
            const fontFamily = fontFamilyMap[fontName] || "Gothic";
            let base = baseTracking[fontFamily]?.[styleId] || 
                       baseTracking[fontFamily]?.default || 0;
            
            // æ–‡å­—ã®ç‰¹å¾´é‡ã‚’å–å¾—
            const leftFeatures = getCharFeatures(leftChar, fontName, baseWidthPx);
            const rightFeatures = getCharFeatures(rightChar, fontName, baseWidthPx);
            
            // å¹³å‡æ–‡å­—å¹…ã‚’è¨ˆç®—
            const avgWidth = (leftFeatures.width + rightFeatures.width) / 2;
            
            // baseãŒ0ã®å ´åˆã¯ã€Phase1ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
            // Phase1ã®gap_norm_avgã®å¹³å‡ã¯ç´„0.35ï¼ˆæ–‡å­—å¹…ã®35%ï¼‰
            // ã“ã‚Œã‚’ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã¨ã—ã¦ä½¿ç”¨
            if (base === 0) {
                // æ–‡å­—å¹…ã«å¯¾ã™ã‚‹æ¯”ç‡ã¨ã—ã¦0.35ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã™ã‚‹
                // ãŸã ã—ã€fontSizeã«å¯¾ã™ã‚‹æ¯”ç‡ã¨ã—ã¦æ‰±ã†ãŸã‚ã€avgWidth/baseWidthPxã§ã‚¹ã‚±ãƒ¼ãƒ«
                base = 0.35 * (avgWidth / baseWidthPx);
            }
            
            // ãƒšã‚¢ã‚«ãƒ†ã‚´ãƒªè£œæ­£
            const pairCat = getPairCategory(leftFeatures.charType, rightFeatures.charType);
            const pairAdj = pairCategoryAdjust[pairCat] || 0;
            
            // é»’å¯†åº¦è£œæ­£
            const densityKey = leftFeatures.density + "-" + rightFeatures.density;
            const densAdj = densityAdjust[densityKey] || 0;
            
            // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆWAVEæ–‡å­—åˆ—ã®å ´åˆï¼‰
            if (leftChar === 'W' && rightChar === 'A' || 
                leftChar === 'A' && rightChar === 'V' || 
                leftChar === 'V' && rightChar === 'E') {
                console.log(`[Phase0] ${leftChar}|${rightChar}:`);
                console.log(`  fontFamily: ${fontFamily}, styleId: ${styleId}`);
                console.log(`  base: ${base.toFixed(4)}, pairAdj: ${pairAdj}, densAdj: ${densAdj}`);
                console.log(`  avgWidth: ${avgWidth.toFixed(2)}px, baseWidthPx: ${baseWidthPx}, globalTracking: ${globalTracking}`);
                console.log(`  gapè¨ˆç®—å‰: ${base.toFixed(4)} * ${baseWidthPx} + ${pairAdj} * ${avgWidth.toFixed(2)} + ${densAdj} * ${avgWidth.toFixed(2)} + ${globalTracking}`);
            }
            
            // æœ€çµ‚ã‚®ãƒ£ãƒƒãƒ—
            // baseã¯fontSizeã«å¯¾ã™ã‚‹æ¯”ç‡ã€pairAdjã¨densAdjã¯æ–‡å­—å¹…ã«å¯¾ã™ã‚‹æ¯”ç‡ã¨ã—ã¦æ‰±ã†
            // globalTrackingã¯pxå˜ä½
            let gap = base * baseWidthPx + (pairAdj + densAdj) * avgWidth + globalTracking;
            
            // æœ€å°ãƒ»æœ€å¤§ã®ã‚¬ãƒ¼ãƒ‰
            const minGap = -0.2 * baseWidthPx;
            const maxGap = 0.8 * baseWidthPx;
            const gapBeforeClamp = gap;
            if (gap < minGap) gap = minGap;
            if (gap > maxGap) gap = maxGap;
            
            // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆWAVEæ–‡å­—åˆ—ã®å ´åˆï¼‰
            if (leftChar === 'W' && rightChar === 'A' || 
                leftChar === 'A' && rightChar === 'V' || 
                leftChar === 'V' && rightChar === 'E') {
                console.log(`  gapè¨ˆç®—å¾Œ: ${gapBeforeClamp.toFixed(3)}px`);
                console.log(`  minGap: ${minGap.toFixed(3)}px, maxGap: ${maxGap.toFixed(3)}px`);
                console.log(`  gapï¼ˆã‚¯ãƒ©ãƒ³ãƒ—å¾Œï¼‰: ${gap.toFixed(3)}px`);
            }
            
            return gap;
        }
        
        // ============================================
        // Phase1ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°é–¢æ•°
        // ============================================
        
        function getKerningPhase1(leftChar, rightChar, fontName, baseWidthPx, globalTracking = 0) {
            if (!phase1Model) {
                return null;
            }
            
            // ãƒšã‚¢ã‚­ãƒ¼ã‚’ç”Ÿæˆ
            const pairKey = leftChar + "|" + rightChar;
            
            // ãƒ•ã‚©ãƒ³ãƒˆå›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’å„ªå…ˆçš„ã«æ¤œç´¢
            // å„ªå…ˆé †ä½:
            // 1. ãƒ•ã‚©ãƒ³ãƒˆåã§ç›´æ¥æ¤œç´¢ï¼ˆãƒ•ã‚©ãƒ³ãƒˆå›ºæœ‰ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ - æœ€å„ªå…ˆï¼‰
            // 2. é•·éŸ³ç¬¦ã‚’ãƒã‚¤ãƒ•ãƒ³ã«å¤‰æ›ã—ã¦æ¤œç´¢ï¼ˆè¡¨è¨˜æºã‚Œå¯¾å¿œï¼‰
            // 3. æ­£è¦åŒ–ã•ã‚ŒãŸã‚«ãƒ†ã‚´ãƒªã§æ¤œç´¢ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ - ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼‰
            let record = null;
            let usedKey = null;
            let dataSource = null; // "font-specific", "font-normalized", "category"
            
            if (phase1Model[fontName] && phase1Model[fontName][pairKey]) {
                record = phase1Model[fontName][pairKey];
                usedKey = fontName;
                dataSource = "font-specific";
            } else {
                // é•·éŸ³ç¬¦ã‚’ãƒã‚¤ãƒ•ãƒ³ã«å¤‰æ›ã—ã¦æ¤œç´¢
                const normalizedName = fontName.replace(/ãƒ¼/g, '-').replace(/ï¼/g, '-');
                if (normalizedName !== fontName && phase1Model[normalizedName] && phase1Model[normalizedName][pairKey]) {
                    record = phase1Model[normalizedName][pairKey];
                    usedKey = normalizedName;
                    dataSource = "font-normalized";
                } else {
                    // ãƒ•ã‚©ãƒ³ãƒˆåãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€æ­£è¦åŒ–ã•ã‚ŒãŸã‚«ãƒ†ã‚´ãƒªã§æ¤œç´¢ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                    const fontKey = normalizeFontName(fontName);
                    if (phase1Model[fontKey] && phase1Model[fontKey][pairKey]) {
                        record = phase1Model[fontKey][pairKey];
                        usedKey = fontKey;
                        dataSource = "category";
                    }
                }
            }
            
            // ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´ã‚’ä¿‚æ•°ã«å¤‰æ›ï¼ˆ-50ï½+50 â†’ 0.5ï½1.5ï¼‰
            // ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´=0ã®å ´åˆã¯ä¿‚æ•°=1.0ï¼ˆå…ƒã®å€¤ï¼‰
            // ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´=+50ã®å ´åˆã¯ä¿‚æ•°=1.5ï¼ˆ50%åºƒã’ã‚‹ï¼‰
            // ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´=-50ã®å ´åˆã¯ä¿‚æ•°=0.5ï¼ˆ50%è©°ã‚ã‚‹ï¼‰
            const trackingCoefficient = 1.0 + (globalTracking / 100);
            
            // ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®å‡¦ç†ï¼ˆé¸æŠã•ã‚ŒãŸã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«å¿œã˜ã¦ï¼‰
            if (!record) {
                // ãƒ‡ãƒãƒƒã‚°: æœªå­¦ç¿’ãƒšã‚¢ã®å‡¦ç†
                console.log(`[getKerningPhase1] æœªå­¦ç¿’ãƒšã‚¢: ${pairKey}, ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : ${unlearnedPairAlgorithm}`);
                
                if (unlearnedPairAlgorithm === "average") {
                    // ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 1: æœªå­¦ç¿’ãƒšã‚¢ã«å­¦ç¿’æ¸ˆã¿ãƒšã‚¢ã®å¹³å‡å€¤ã‚’ä½¿ç”¨
                    if (phase1ModelAverage !== null && phase1ModelAverage !== undefined) {
                        const leftFeatures = getCharFeatures(leftChar, fontName, baseWidthPx);
                        const rightFeatures = getCharFeatures(rightChar, fontName, baseWidthPx);
                        const avgWidth = (leftFeatures.width + rightFeatures.width) / 2;
                        const gapPx = phase1ModelAverage * avgWidth * trackingCoefficient;
                        console.log(`[getKerningPhase1] å¹³å‡å€¤ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : gapPx = ${gapPx.toFixed(3)}px`);
                        return gapPx;
                    }
                    // å¹³å‡å€¤ã‚‚è¨ˆç®—ã§ããªã„å ´åˆã¯nullã‚’è¿”ã™ï¼ˆPhase0ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                    console.log(`[getKerningPhase1] å¹³å‡å€¤ãŒè¨ˆç®—ã§ããªã„ãŸã‚nullã‚’è¿”ã™`);
                    return null;
                } else if (unlearnedPairAlgorithm === "phase0") {
                    // ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 2: Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    console.log(`[getKerningPhase1] Phase0ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: nullã‚’è¿”ã™`);
                    return null;  // nullã‚’è¿”ã™ã¨getKerningé–¢æ•°ã§Phase0ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã‚Œã‚‹
                } else if (unlearnedPairAlgorithm === "phase0_scaled") {
                    // ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 3: Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ Ã— ä¿‚æ•°ï¼ˆæ–‡å­—åˆ—å…¨ä½“ã®å¹…ã«å¿œã˜ãŸèª¿æ•´ï¼‰
                    // Phase0ã§è¨ˆç®—ã—ãŸgapã‚’å–å¾—
                    const phase0Gap = getKerningPhase0(leftChar, rightChar, fontName, baseWidthPx, "default", 0);
                    
                    // ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆæ–‡å­—åˆ—å…¨ä½“ã®å¹…ã«å¿œã˜ãŸãƒãƒ©ãƒ³ã‚¹èª¿æ•´ï¼‰
                    // æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’è€ƒæ…®ã—ã¦ã€å­¦ç¿’æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã¨Phase0ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚‹
                    let scaleFactor = 1.0;
                    
                    if (phase1ModelAverage !== null && phase1ModelAverage !== undefined && currentTextInfo !== null) {
                        // æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’è€ƒæ…®ã—ãŸä¿‚æ•°ã‚’è¨ˆç®—
                        // Phase0ã§è¨ˆç®—ã—ãŸæ–‡å­—åˆ—å…¨ä½“ã®å¹…ã¨ã€å­¦ç¿’æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ¨å®šã•ã‚Œã‚‹æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’æ¯”è¼ƒ
                        const phase0TotalWidth = currentTextInfo.phase0TotalWidth;
                        const estimatedPhase1TotalWidth = currentTextInfo.estimatedPhase1TotalWidth;
                        
                        if (phase0TotalWidth > 0 && estimatedPhase1TotalWidth > 0) {
                            // æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã®æ¯”ç‡ã‚’ä¿‚æ•°ã¨ã—ã¦ä½¿ç”¨
                            // ã“ã‚Œã«ã‚ˆã‚Šã€æ–‡å­—åˆ—å…¨ä½“ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ä¿ã¡ãªãŒã‚‰èª¿æ•´ã•ã‚Œã‚‹
                            scaleFactor = estimatedPhase1TotalWidth / phase0TotalWidth;
                        } else {
                            // æ–‡å­—åˆ—å…¨ä½“ã®å¹…ãŒè¨ˆç®—ã§ããªã„å ´åˆã¯ã€gap_normå€¤ã§æ¯”è¼ƒï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                            const leftFeatures = getCharFeatures(leftChar, fontName, baseWidthPx);
                            const rightFeatures = getCharFeatures(rightChar, fontName, baseWidthPx);
                            const avgWidth = (leftFeatures.width + rightFeatures.width) / 2;
                            
                            if (avgWidth > 0) {
                                const phase0GapNorm = phase0Gap / avgWidth;
                                if (phase0GapNorm !== 0 && Math.abs(phase0GapNorm) > 0.001) {
                                    scaleFactor = phase1ModelAverage / phase0GapNorm;
                                }
                            }
                        }
                    }
                    
                    // Phase0ã®gapã«ä¿‚æ•°ã‚’ã‹ã‘ã‚‹
                    // ä¿‚æ•°ãŒæ¥µç«¯ãªå€¤ã«ãªã‚‰ãªã„ã‚ˆã†ã«åˆ¶é™ï¼ˆ0.1 ï½ 10.0ï¼‰
                    scaleFactor = Math.max(0.1, Math.min(10.0, scaleFactor));
                    const gapPx = phase0Gap * scaleFactor * trackingCoefficient;
                    console.log(`[getKerningPhase1] Phase0ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : phase0Gap = ${phase0Gap.toFixed(3)}px, scaleFactor = ${scaleFactor.toFixed(3)}, gapPx = ${gapPx.toFixed(3)}px`);
                    return gapPx;
                }
                
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: nullã‚’è¿”ã—ã¦Phase0ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                console.log(`[getKerningPhase1] ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: nullã‚’è¿”ã™`);
                return null;
            }
            
            // ãƒ‡ãƒãƒƒã‚°: N|Iãƒšã‚¢ã®å ´åˆã®ã¿è©³ç´°ãƒ­ã‚°ã‚’å‡ºåŠ›
            if (leftChar === 'N' && rightChar === 'I') {
                console.log(`[getKerningPhase1] ${pairKey} ãƒšã‚¢:`);
                console.log(`  ãƒ•ã‚©ãƒ³ãƒˆå: ${fontName}`);
                console.log(`  ä½¿ç”¨ã•ã‚ŒãŸã‚­ãƒ¼: ${usedKey} (${dataSource})`);
            }
            
            // gap_normã‹ã‚‰pxå˜ä½ã«å¤‰æ›
            // å¹³å‡æ–‡å­—å¹…ã§æ­£è¦åŒ–ã—ãŸgap_norm_avgã‚’å„ªå…ˆä½¿ç”¨ï¼ˆå­¦ç¿’æ™‚ã¨ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°è¨ˆç®—æ™‚ã®åŸºæº–ã‚’ä¸€è‡´ï¼‰
            let gapNorm = record.gap_norm_avg;
            
            // å¾Œæ–¹äº’æ›æ€§: gap_norm_avgãŒãªã„å ´åˆã¯å·¦å³ã®å¹³å‡ã‚’ä½¿ç”¨
            if (gapNorm === undefined || gapNorm === null) {
                const gapNormLeft = record.gap_norm_left_avg;
                const gapNormRight = record.gap_norm_right_avg;
                
                if (gapNormLeft === undefined || gapNormLeft === null ||
                    gapNormRight === undefined || gapNormRight === null) {
                    return null;
                }
                
                // å·¦å³ã®å¹³å‡ã‚’å–ã‚‹ï¼ˆæ—§æ–¹å¼ï¼‰
                gapNorm = (gapNormLeft + gapNormRight) / 2;
            }
            
            // æ¡ˆ1: å­¦ç¿’æ™‚ã®gap_actual_avgã‚’æ–‡å­—å¹…ã®æ¯”ç‡ã§èª¿æ•´
            // Canvas APIã®measureTextã¨SVGã®bboxã®å·®ã‚’è€ƒæ…®ã—ã¦ã€æ–‡å­—å¹…ã®æ¯”ç‡ã§è£œæ­£
            const learnedFontSize = record.font_size_avg;
            const gapActualAvg = record.gap_actual_avg;
            
            if (learnedFontSize !== undefined && learnedFontSize !== null && 
                gapActualAvg !== undefined && gapActualAvg !== null) {
                // ç¾åœ¨ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã§æ–‡å­—å¹…ã‚’æ¸¬å®š
                const leftFeatures = getCharFeatures(leftChar, fontName, baseWidthPx);
                const rightFeatures = getCharFeatures(rightChar, fontName, baseWidthPx);
                
                // å­¦ç¿’æ™‚ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã§æ–‡å­—å¹…ã‚’æ¸¬å®š
                const leftFeaturesLearned = getCharFeatures(leftChar, fontName, learnedFontSize);
                const rightFeaturesLearned = getCharFeatures(rightChar, fontName, learnedFontSize);
                
                // SVGã®bboxã¨Canvas APIã®measureText().widthã®å·®ã‚’è£œæ­£
                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã§ã¯ã€SVGã®bboxã‚’ä½¿ç”¨ã—ã¦gap_actualã‚’è¨ˆç®—
                // gap_actual = next.min_x - current.max_x
                // Canvas APIã§ã¯ã€measureText().widthã‚’ä½¿ç”¨ã—ã¦æ–‡å­—å¹…ã‚’æ¸¬å®š
                // 
                // é‡è¦ãªç‚¹: gap_actualã¯SVGã®bboxã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€
                // Canvas APIã§å†ç¾ã™ã‚‹ã«ã¯ã€SVGã®bboxã¨Canvas APIã®measureText().widthã®æ¯”ç‡ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                // 
                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰:
                // - SVG bbox: N=36.72px, I=17.08px, å¹³å‡=26.90px
                // - Canvas API measureText: N=ç´„31px, I=ç´„15px, å¹³å‡=ç´„23px
                // - æ¯”ç‡: Canvas API / SVG bbox = 23 / 26.90 â‰ˆ 0.855
                // 
                // gap_actualã¯æ–‡å­—é–“ã®å®Ÿéš›ã®è·é›¢ãªã®ã§ã€æ–‡å­—å¹…ã«æ¯”ä¾‹ã™ã‚‹
                // ã—ãŸãŒã£ã¦ã€Canvas APIã§å†ç¾ã™ã‚‹ã«ã¯:
                // gapPx = gap_actual * (currentFontSize / learnedFontSize) * (Canvas API / SVG bbox ã®æ¯”ç‡)
                
                // ç¾åœ¨ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã§ã®measureText().width
                const currentLeftWidth = leftFeatures.width; // measureText().width
                const currentRightWidth = rightFeatures.width; // measureText().width
                const currentAvgWidth = (currentLeftWidth + currentRightWidth) / 2;
                
                // å­¦ç¿’æ™‚ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã§ã®measureText().width
                const learnedLeftWidth = leftFeaturesLearned.width; // measureText().width
                const learnedRightWidth = rightFeaturesLearned.width; // measureText().width
                const learnedAvgWidth = (learnedLeftWidth + learnedRightWidth) / 2;
                
                // æ ¹æœ¬çš„ãªå•é¡Œã®å†è€ƒ:
                // SVGã®bbox: N.max_x = 340.05px, I.min_x = 348.67px, gap_actual = 8.615px
                // Canvas API: fillText(x, y)ã®xåº§æ¨™ã¯ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã®å·¦ç«¯
                // 
                // é‡è¦ãªç†è§£:
                // gap_actualã¯ã€ŒIã®å·¦ç«¯ï¼ˆSVG bboxï¼‰ã‹ã‚‰Nã®å³ç«¯ï¼ˆSVG bboxï¼‰ã¾ã§ã®è·é›¢ã€
                // Canvas APIã§å†ç¾ã™ã‚‹ã«ã¯ã€ã“ã®è·é›¢ã‚’Canvas APIã®åº§æ¨™ç³»ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                // 
                // ã—ã‹ã—ã€SVGã®bboxã¨Canvas APIã®measureText().widthã®æ¯”ç‡ã¯ç´„0.86
                // ã“ã‚Œã¯æ–‡å­—å¹…ã®æ¯”ç‡ãªã®ã§ã€gap_actualã«ã‚‚åŒã˜æ¯”ç‡ã‚’é©ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                // 
                // ã—ã‹ã—ã€gap_actualã¯ã€Œè·é›¢ã€ãªã®ã§ã€æ–‡å­—å¹…ã®æ¯”ç‡ã‚’ãã®ã¾ã¾é©ç”¨ã™ã‚‹ã®ã¯æ­£ã—ããªã„
                // gap_actualã¯æ–‡å­—é–“ã®ã€Œç©ºç™½ã€ã®è·é›¢ãªã®ã§ã€æ–‡å­—å¹…ã«æ¯”ä¾‹ã™ã‚‹
                // 
                // ã—ãŸãŒã£ã¦ã€gap_actualã‚’Canvas APIã§å†ç¾ã™ã‚‹ã«ã¯:
                // gapPx = gap_actual * (currentFontSize / learnedFontSize) * (Canvas API measureText / SVG bbox ã®æ¯”ç‡)
                // 
                // ã—ã‹ã—ã€ã“ã®æ¯”ç‡ã¯æ–‡å­—å¹…ã®æ¯”ç‡ãªã®ã§ã€gap_actualã«ã‚‚åŒã˜æ¯”ç‡ã‚’é©ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                // 
                // ã‚ˆã‚Šæ­£ç¢ºã«ã¯:
                // gap_actualã¯æ–‡å­—é–“ã®è·é›¢ãªã®ã§ã€æ–‡å­—å¹…ã«æ¯”ä¾‹ã™ã‚‹
                // ã—ãŸãŒã£ã¦ã€gap_actualã‚’Canvas APIã§å†ç¾ã™ã‚‹ã«ã¯ã€æ–‡å­—å¹…ã®æ¯”ç‡ã‚’é©ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                // 
                // ã—ã‹ã—ã€è©¦è¡Œ1ã§ã¯ã€Œè¨ˆç®—å€¤ã¯æ­£ã—ã„ãŒã€è¦–è¦šçš„ã«åºƒã„ã€ã¨ã„ã†çµæœã ã£ãŸ
                // ã“ã‚Œã¯ã€è¨ˆç®—å€¤ãŒæ­£ã—ã„ã®ã«è¦–è¦šçš„ã«åºƒãè¦‹ãˆã‚‹ã¨ã„ã†çŸ›ç›¾
                // 
                // æœ¬å½“ã®å•é¡Œã¯ã€ä½ç½®è¨ˆç®—ã®åŸºæº–ç‚¹ãŒç•°ãªã‚‹ã“ã¨ã‹ã‚‚ã—ã‚Œãªã„
                // SVG: bboxã®min_x/max_xã§é…ç½®
                // Canvas API: fillText(x, y)ã®xåº§æ¨™ãŒãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã®å·¦ç«¯
                // 
                // ã—ãŸãŒã£ã¦ã€ä½ç½®è¨ˆç®—ã§actualBoundingBoxRightã¨actualBoundingBoxLeftã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€
                // SVGã®bboxã‚’åŸºæº–ã«ã—ãŸä½ç½®è¨ˆç®—ãŒã§ãã‚‹ã¯ãš
                // 
                // ã—ã‹ã—ã€actualBoundingBoxRightã¨actualBoundingBoxLeftãŒæ­£ã—ãå–å¾—ã§ãã¦ã„ã‚‹ã‹ã©ã†ã‹ãŒå•é¡Œ
                // 
                // ã‚ˆã‚Šç¢ºå®Ÿãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:
                // gap_actualã¯SVGã®bboxã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€Canvas APIã§å†ç¾ã™ã‚‹ã«ã¯ã€
                // SVGã®bboxã¨Canvas APIã®measureText().widthã®æ¯”ç‡ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                // 
                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰: N|Iãƒšã‚¢ã®å ´åˆ
                // - SVG bboxå¹³å‡: 26.90px
                // - Canvas API measureTextå¹³å‡: ç´„23pxï¼ˆå­¦ç¿’æ™‚ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º45pxã§æ¸¬å®šï¼‰
                // - æ¯”ç‡: Canvas API / SVG bbox = 23 / 26.90 â‰ˆ 0.855
                // 
                // é‡è¦ãªç†è§£:
                // gap_actualã¯SVGã®bboxåŸºæº–ã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹ï¼ˆI.min_x - N.max_xï¼‰
                // ä½ç½®è¨ˆç®—ã§actualBoundingBoxRightã¨actualBoundingBoxLeftã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€
                // gap_actualã¯ãã®ã¾ã¾ä½¿ç”¨ã—ã€ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã§ã‚¹ã‚±ãƒ¼ãƒ«ã™ã‚‹ã ã‘
                // ãªãœãªã‚‰ã€actualBoundingBoxRightã¨actualBoundingBoxLeftã¯æ—¢ã«Canvas APIã®åº§æ¨™ç³»ã«å¤‰æ›ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰
                // 
                // ã—ã‹ã—ã€SVGã®bboxã¨Canvas APIã®actualBoundingBoxã®æ¯”ç‡ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰: N|Iãƒšã‚¢ã®å ´åˆ
                // - SVG bbox: N=36.72px, I=17.08px
                // - Canvas API actualBoundingBox: N=ç´„45px, I=ç´„30pxï¼ˆãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º45pxã§æ¸¬å®šï¼‰
                // 
                // å®Ÿéš›ã«ã¯ã€ä½ç½®è¨ˆç®—ã§actualBoundingBoxRightã¨actualBoundingBoxLeftã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€
                // gap_actualã‚’ãã®ã¾ã¾ä½¿ç”¨ã—ã€ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã§ã‚¹ã‚±ãƒ¼ãƒ«ã™ã‚‹ã ã‘
                const fontSizeScale = baseWidthPx / learnedFontSize;
                const gapPx = gapActualAvg * fontSizeScale;
                
                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
                if (leftChar === 'N' && rightChar === 'I') {
                    console.log('N|I ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°è¨ˆç®—ï¼ˆSVG bboxåŸºæº–ï¼‰:');
                    console.log('  å­¦ç¿’æ™‚ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º:', learnedFontSize.toFixed(2), 'px');
                    console.log('  ç¾åœ¨ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º:', baseWidthPx, 'px');
                    console.log('  å­¦ç¿’æ™‚ã®gap_actual_avg (SVG bboxåŸºæº–):', gapActualAvg.toFixed(3), 'px');
                    console.log('  ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã®æ¯”ç‡:', fontSizeScale.toFixed(4));
                    console.log('  è¨ˆç®—ã•ã‚ŒãŸgapPx:', gapPx.toFixed(3), 'px');
                    console.log('  ç¾åœ¨ã®Nã®å¹…ï¼ˆmeasureTextï¼‰:', currentLeftWidth.toFixed(2), 'px');
                    console.log('  ç¾åœ¨ã®Iã®å¹…ï¼ˆmeasureTextï¼‰:', currentRightWidth.toFixed(2), 'px');
                }
                
                // ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´ã‚’ä¿‚æ•°ã¨ã—ã¦é©ç”¨
                return gapPx * trackingCoefficient;
            }
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: gap_normã‚’ä½¿ç”¨ï¼ˆæ—§æ–¹å¼ï¼‰
            const fontSizeToUse = (learnedFontSize !== undefined && learnedFontSize !== null) 
                ? learnedFontSize 
                : baseWidthPx;
            
            const leftFeatures = getCharFeatures(leftChar, fontName, fontSizeToUse);
            const rightFeatures = getCharFeatures(rightChar, fontName, fontSizeToUse);
            const avgWidth = (leftFeatures.width + rightFeatures.width) / 2;
            const gapPx = gapNorm * avgWidth;
            // ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´ã‚’ä¿‚æ•°ã¨ã—ã¦é©ç”¨
            return gapPx * trackingCoefficient;
        }
        
        // ============================================
        // ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ãŸãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°
        // ============================================
        
        function getKerning(leftChar, rightChar, fontName, baseWidthPx, styleId = "default", globalTracking = 0) {
            // Phase0ã®å€¤ã‚’å¸¸ã«è¨ˆç®—ï¼ˆãƒ–ãƒ¬ãƒ³ãƒ‰ã«å¿…è¦ï¼‰
            const phase0Gap = getKerningPhase0(leftChar, rightChar, fontName, baseWidthPx, styleId, globalTracking);
            
            // Phase1ãƒ¢ãƒ¼ãƒ‰ã§ãƒ¢ãƒ‡ãƒ«ãŒãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ã®å ´åˆ
            if (phaseMode === "phase1" && phase1Model) {
                const phase1Gap = getKerningPhase1(leftChar, rightChar, fontName, baseWidthPx, globalTracking);
                
                // Phase1ã®å€¤ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆï¼ˆå­¦ç¿’æ¸ˆã¿ãƒšã‚¢ã€ã¾ãŸã¯æœªå­¦ç¿’ãƒšã‚¢ã®å‡¦ç†æ–¹æ³•ã§è¨ˆç®—ã•ã‚ŒãŸå€¤ï¼‰
                if (phase1Gap !== null) {
                    // Phase1ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€blendRatioãŒ0ã§ã‚‚Phase1ã®å€¤ï¼ˆæœªå­¦ç¿’ãƒšã‚¢ã®å‡¦ç†æ–¹æ³•ã‚’å«ã‚€ï¼‰ã‚’ä½¿ç”¨
                    // blendRatioã¯Phase0ã¨Phase1ã®ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ã ãŒã€Phase1ãƒ¢ãƒ¼ãƒ‰ã§ã¯Phase1ã®å€¤ã‚’å„ªå…ˆ
                    if (blendRatio <= 0.0) {
                        // blendRatio = 0ã®å ´åˆã§ã‚‚ã€Phase1ãƒ¢ãƒ¼ãƒ‰ã§ã¯Phase1ã®å€¤ã‚’ä½¿ç”¨
                        return phase1Gap;
                    } else if (blendRatio >= 1.0) {
                        return phase1Gap;
                    } else {
                        // ãƒ–ãƒ¬ãƒ³ãƒ‰: (1 - blendRatio) * phase0Gap + blendRatio * phase1Gap
                        return (1.0 - blendRatio) * phase0Gap + blendRatio * phase1Gap;
                    }
                }
                
                // Phase1ã§å€¤ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆï¼ˆæœªå­¦ç¿’ãƒšã‚¢ã§ã€unlearnedPairAlgorithm === "phase0"ã®å ´åˆã®ã¿ï¼‰
                // ã“ã®å ´åˆã€getKerningPhase1ã¯nullã‚’è¿”ã™ã®ã§ã€Phase0ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                // ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ãŒ0ã®å ´åˆã¯Phase0ã®ã¿
                if (blendRatio <= 0.0) {
                    return phase0Gap;
                } else {
                    // æœªå­¦ç¿’ãƒšã‚¢ã§ã‚‚ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ãŒ0ã‚ˆã‚Šå¤§ãã„å ´åˆã¯ã€Phase0ã®ã¿ã‚’è¿”ã™
                    // ï¼ˆæœªå­¦ç¿’ãƒšã‚¢ã®å ´åˆã¯Phase1ã®å€¤ãŒnullãªã®ã§ã€Phase0ã®ã¿ãŒé©åˆ‡ï¼‰
                    return phase0Gap;
                }
            }
            
            // Phase0ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ãƒ¢ãƒ‡ãƒ«æœªãƒ­ãƒ¼ãƒ‰ã®å ´åˆã¯Phase0ã‚’ä½¿ç”¨
            return phase0Gap;
        }
        
        // ============================================
        // Phase0ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ä½ç½®è¨ˆç®—ï¼ˆæ—¢å­˜é–¢æ•°ã‚’ä¿æŒï¼‰
        // ============================================
        
        function computeKerningPositions(text, fontId, fontSize, styleId, globalTracking = 0) {
            const fontFamily = fontFamilyMap[fontId] || "Gothic";
            const base = baseTracking[fontFamily]?.[styleId] || 
                        baseTracking[fontFamily]?.default || 0;

            // Phase1ãƒ¢ãƒ¼ãƒ‰ã§phase0_scaledã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã€
            // äº‹å‰ã«Phase0ã®å¹…ã‚’è¨ˆç®—ã—ã¦currentTextInfoã‚’è¨­å®š
            // ï¼ˆgetKerningPhase1ãŒå‘¼ã°ã‚Œã‚‹æ™‚ç‚¹ã§currentTextInfoãŒå¿…è¦ãªãŸã‚ï¼‰
            if (phaseMode === "phase1" && unlearnedPairAlgorithm === "phase0_scaled" && !isComputingPhase0Width) {
                const originalPhaseMode = phaseMode;
                isComputingPhase0Width = true;
                phaseMode = "phase0";
                const phase0Result = computeKerningPositions(text, fontId, fontSize, styleId, globalTracking);
                const phase0TotalWidth = phase0Result.totalWidth || 0;
                phaseMode = originalPhaseMode;
                isComputingPhase0Width = false;
                
                // estimatedPhase1TotalWidthã¯ã€å®Ÿéš›ã®Phase1è¨ˆç®—å¾Œã«æ›´æ–°ã•ã‚Œã‚‹ãŸã‚ã€
                // ã“ã“ã§ã¯ä¸€æ™‚çš„ã«phase0TotalWidthã¨åŒã˜å€¤ã«è¨­å®š
                // ï¼ˆå¾Œã§computeKerningPositionsã®æœ€å¾Œã§æ›´æ–°ã•ã‚Œã‚‹ï¼‰
                currentTextInfo = {
                    phase0TotalWidth: phase0TotalWidth,
                    estimatedPhase1TotalWidth: phase0TotalWidth,  // ä¸€æ™‚çš„ãªå€¤ã€å¾Œã§æ›´æ–°
                    text: text,
                    fontId: fontId,
                    fontSize: fontSize
                };
            }

            // å„æ–‡å­—ã®ç‰¹å¾´é‡ã‚’å–å¾—
            const chars = Array.from(text);
            const features = chars.map(ch => getCharFeatures(ch, fontId, fontSize));

            // ä½ç½®è¨ˆç®—
            const startX = 50;
            const getInkLeft = (feature) => {
                if (feature && Number.isFinite(feature.inkLeft)) return feature.inkLeft;
                if (feature && Number.isFinite(feature.actualBoundingBoxLeft)) {
                    return -feature.actualBoundingBoxLeft;
                }
                return 0;
            };
            const getInkRight = (feature) => {
                if (feature && Number.isFinite(feature.inkRight)) return feature.inkRight;
                if (feature && Number.isFinite(feature.actualBoundingBoxRight)) {
                    return feature.actualBoundingBoxRight;
                }
                if (feature && Number.isFinite(feature.width)) return feature.width;
                return fontSize * 0.6;
            };
            // æœ€åˆã®æ–‡å­—ã‚’startXã«æƒãˆã‚‹ï¼ˆå®Ÿéš›ã®å·¦ç«¯ãŒstartXï¼‰
            let x = startX;
            if (features.length > 0) {
                x = startX - getInkLeft(features[0]);
            }
            const positions = [x];
            const gaps = [];
            const pairAdjusts = [];
            const densityAdjusts = [];
            const pairCategories = [];
            const isLearned = [];  // å„ãƒšã‚¢ãŒå­¦ç¿’æ¸ˆã¿ã‹ã©ã†ã‹ï¼ˆPhase1ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿æœ‰åŠ¹ï¼‰
            const phase0Gaps = [];  // å„ãƒšã‚¢ã®Phase0ã‚®ãƒ£ãƒƒãƒ—å€¤ï¼ˆè©•ä¾¡ç”¨ï¼‰
            const phase1Gaps = [];  // å„ãƒšã‚¢ã®Phase1ã‚®ãƒ£ãƒƒãƒ—å€¤ï¼ˆè©•ä¾¡ç”¨ã€ãƒ–ãƒ¬ãƒ³ãƒ‰å‰ï¼‰

            for (let i = 0; i < chars.length - 1; i++) {
                const A = features[i];
                const B = features[i + 1];
                const leftChar = chars[i];
                const rightChar = chars[i + 1];

                // Phase1ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ãƒšã‚¢ãŒå­¦ç¿’æ¸ˆã¿ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                let pairIsLearned = true;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å­¦ç¿’æ¸ˆã¿ï¼ˆPhase0ãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰
                if (phaseMode === "phase1" && phase1Model) {
                    const pairKey = leftChar + "|" + rightChar;
                    // ãƒ•ã‚©ãƒ³ãƒˆåã§ç›´æ¥æ¤œç´¢
                    if (phase1Model[fontId] && phase1Model[fontId][pairKey]) {
                        pairIsLearned = true;
                    } else {
                        // é•·éŸ³ç¬¦ã‚’ãƒã‚¤ãƒ•ãƒ³ã«å¤‰æ›ã—ã¦æ¤œç´¢
                        const normalizedName = fontId.replace(/ãƒ¼/g, '-').replace(/ï¼/g, '-');
                        if (normalizedName !== fontId && phase1Model[normalizedName] && phase1Model[normalizedName][pairKey]) {
                            pairIsLearned = true;
                        } else {
                            // æ­£è¦åŒ–ã•ã‚ŒãŸã‚«ãƒ†ã‚´ãƒªã§æ¤œç´¢
                            const fontKey = normalizeFontName(fontId);
                            if (phase1Model[fontKey] && phase1Model[fontKey][pairKey]) {
                                pairIsLearned = true;
                            } else {
                                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„ = æœªå­¦ç¿’ãƒšã‚¢
                                pairIsLearned = false;
                            }
                        }
                    }
                }
                isLearned.push(pairIsLearned);

                // Phase0ã¨Phase1ã®ã‚®ãƒ£ãƒƒãƒ—ã‚’å€‹åˆ¥ã«è¨ˆç®—ï¼ˆè©•ä¾¡ç”¨ï¼‰
                const phase0Gap = getKerningPhase0(leftChar, rightChar, fontId, fontSize, styleId, globalTracking);
                phase0Gaps.push(phase0Gap);
                
                let phase1GapValue = phase0Gap;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯Phase0
                if (phaseMode === "phase1" && phase1Model) {
                    const phase1Gap = getKerningPhase1(leftChar, rightChar, fontId, fontSize, globalTracking);
                    if (phase1Gap !== null) {
                        // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚’é©ç”¨ã™ã‚‹å‰ã®Phase1ã®å€¤ã‚’ä¿å­˜
                        phase1GapValue = phase1Gap;
                    }
                }
                phase1Gaps.push(phase1GapValue);

                // getKerningé–¢æ•°ã‚’ä½¿ç”¨ï¼ˆPhase0/Phase1è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆã€ãƒ–ãƒ¬ãƒ³ãƒ‰é©ç”¨æ¸ˆã¿ï¼‰
                let gap = getKerning(leftChar, rightChar, fontId, fontSize, styleId, globalTracking);
                
                // æœ€å°ãƒ»æœ€å¤§ã®ã‚¬ãƒ¼ãƒ‰
                const minGap = -0.2 * fontSize;
                const maxGap = 0.8 * fontSize;
                if (gap < minGap) gap = minGap;
                if (gap > maxGap) gap = maxGap;

                // æ¬¡ã®æ–‡å­—ã®Xåº§æ¨™ã‚’è¨ˆç®—ï¼ˆã‚¤ãƒ³ã‚¯é ˜åŸŸåŸºæº–ï¼‰
                if (leftChar === 'N' && rightChar === 'I') {
                    console.log('N|I ä½ç½®è¨ˆç®—:');
                    console.log('  ç¾åœ¨ã®xåº§æ¨™:', x.toFixed(2), 'px');
                    console.log('  N.actualBoundingBoxRight:', (A.actualBoundingBoxRight !== undefined ? A.actualBoundingBoxRight : 'undefined'));
                    console.log('  N.actualBoundingBoxLeft:', (A.actualBoundingBoxLeft !== undefined ? A.actualBoundingBoxLeft : 'undefined'));
                    console.log('  N.inkLeft:', getInkLeft(A).toFixed(2), 'px');
                    console.log('  N.inkRight:', getInkRight(A).toFixed(2), 'px');
                    console.log('  N.width (measureText):', A.width.toFixed(2), 'px');
                    console.log('  gap:', gap.toFixed(3), 'px');
                    console.log('  I.actualBoundingBoxRight:', (B.actualBoundingBoxRight !== undefined ? B.actualBoundingBoxRight : 'undefined'));
                    console.log('  I.actualBoundingBoxLeft:', (B.actualBoundingBoxLeft !== undefined ? B.actualBoundingBoxLeft : 'undefined'));
                    console.log('  I.inkLeft:', getInkLeft(B).toFixed(2), 'px');
                    console.log('  I.inkRight:', getInkRight(B).toFixed(2), 'px');
                    console.log('  I.width (measureText):', B.width.toFixed(2), 'px');
                }
                
                // ç¾åœ¨ã®xåº§æ¨™ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                const prevX = x;
                const currentRightEdge = prevX + getInkRight(A);
                const nextLeftEdge = currentRightEdge + gap;
                x = nextLeftEdge - getInkLeft(B);
                
                positions.push(x);
                gaps.push(gap);
                
                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆN|Iãƒšã‚¢ã®å ´åˆï¼‰
                if (leftChar === 'N' && rightChar === 'I') {
                    console.log('  Nã®å¹…ï¼ˆmeasureTextï¼‰:', A.width.toFixed(2), 'px');
                    console.log('  gap:', gap.toFixed(3), 'px');
                    const dbgRight = currentRightEdge;
                    const dbgLeft = nextLeftEdge;
                    console.log('  Nã®å³ç«¯ï¼ˆã‚¤ãƒ³ã‚¯åŸºæº–ï¼‰:', dbgRight.toFixed(2), 'px');
                    console.log('  Iã®å·¦ç«¯ï¼ˆã‚¤ãƒ³ã‚¯åŸºæº–ï¼‰:', dbgLeft.toFixed(2), 'px');
                    console.log('  å®Ÿéš›ã®gapï¼ˆIã®å·¦ç«¯ - Nã®å³ç«¯ï¼‰:', (dbgLeft - dbgRight).toFixed(3), 'px');
                    console.log('  æ¬¡ã®xåº§æ¨™:', x.toFixed(2), 'px');
                    console.log('  Iã®å¹…ï¼ˆmeasureTextï¼‰:', B.width.toFixed(2), 'px');
                }
                
                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆPhase0ã®è¨ˆç®—å€¤ã‚‚ä¿æŒï¼‰
                const pairCat = getPairCategory(A.charType, B.charType);
                const pairAdj = pairCategoryAdjust[pairCat] || 0;
                const densityKey = A.density + "-" + B.density;
                const densAdj = densityAdjust[densityKey] || 0;
                pairAdjusts.push(pairAdj);
                densityAdjusts.push(densAdj);
                pairCategories.push(pairCat);
            }

            // æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’è¨ˆç®—ï¼ˆæœ€å¾Œã®æ–‡å­—ã®å³ç«¯ã¾ã§ã®è·é›¢ï¼‰
            let totalWidth = 0;
            if (positions.length > 0 && features.length > 0) {
                const lastPos = positions[positions.length - 1];
                const lastFeature = features[features.length - 1];
                const getInkRight = (feature) => {
                    if (feature && Number.isFinite(feature.inkRight)) return feature.inkRight;
                    if (feature && Number.isFinite(feature.actualBoundingBoxRight)) {
                        return feature.actualBoundingBoxRight;
                    }
                    if (feature && Number.isFinite(feature.width)) return feature.width;
                    return fontSize * 0.6;
                };
                totalWidth = lastPos + getInkRight(lastFeature) - startX;
            }
            
            // Phase0ã§è¨ˆç®—ã—ãŸæ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’ä¿å­˜
            // Phase1ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€å®Ÿéš›ã«è¨ˆç®—ã—ãŸæ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚‚ä¿å­˜
            let phase0TotalWidth = totalWidth;
            let phase1TotalWidth = totalWidth;
            
            // Phase1ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€Phase0ã§è¨ˆç®—ã—ãŸå¹…ã‚‚å–å¾—ã™ã‚‹ãŸã‚ã€
            // Phase0ãƒ¢ãƒ¼ãƒ‰ã§ä¸€åº¦è¨ˆç®—ã—ã¦å¹…ã‚’å–å¾—ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ã®ãŸã‚ãƒ•ãƒ©ã‚°ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
            if (phaseMode === "phase1" && !isComputingPhase0Width) {
                // Phase0ã§è¨ˆç®—ã—ãŸæ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’å–å¾—
                // æ³¨æ„: globalTrackingã¯Phase0ã§ã‚‚Phase1ã§ã‚‚åŒã˜å€¤ã‚’ä½¿ç”¨ã™ã‚‹
                // ï¼ˆå¹…ã‚¢ãƒ³ã‚«ãƒ¼ã¯ã€Œå­¦ç¿’ã«ã‚ˆã‚‹å¹…ã®å¤‰åŒ–ã€ã®ã¿ã‚’è£œæ­£ã™ã‚‹ãŸã‚ï¼‰
                const originalPhaseMode = phaseMode;
                isComputingPhase0Width = true;
                phaseMode = "phase0";
                const phase0Result = computeKerningPositions(text, fontId, fontSize, styleId, globalTracking);
                phase0TotalWidth = phase0Result.totalWidth || totalWidth;
                phaseMode = originalPhaseMode;
                isComputingPhase0Width = false;
                
                // Phase1ã§å®Ÿéš›ã«è¨ˆç®—ã—ãŸæ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’ä½¿ç”¨
                phase1TotalWidth = totalWidth;
                
                // ============================================
                // å¹…ã‚¢ãƒ³ã‚«ãƒ¼ï¼ˆå…¨ã‚®ãƒ£ãƒƒãƒ—å‡ç­‰å‰²ã‚Šï¼‰ã®é©ç”¨
                // ============================================
                // æ³¨æ„: ã€ŒPhase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€ã®å ´åˆã¯é©ç”¨ã—ãªã„
                // ï¼ˆæœªå­¦ç¿’ãƒšã‚¢ã¯æ—¢ã«Phase0ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€å¹…ã‚¢ãƒ³ã‚«ãƒ¼ã¯ä¸è¦ï¼‰
                // ã€Œæœªå­¦ç¿’ãƒšã‚¢ã«å¹³å‡å€¤ã‚’ä½¿ç”¨ã€ã¨ã€ŒPhase0 Ã— ä¿‚æ•°ã€ã®å ´åˆã®ã¿é©ç”¨
                const shouldApplyWidthAnchor = unlearnedPairAlgorithm !== "phase0";
                
                if (shouldApplyWidthAnchor) {
                    // Phase1ã¨Phase0ã®æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã®å·®åˆ†ã‚’è¨ˆç®—
                    // ã“ã‚Œã¯ã€Œå­¦ç¿’ã«ã‚ˆã‚‹å¹…ã®å¤‰åŒ–ã€ã®ã¿ã‚’è¡¨ã™
                    const deltaW = phase1TotalWidth - phase0TotalWidth;
                    
                    // ã‚®ãƒ£ãƒƒãƒ—æ•°ãŒ0ã‚ˆã‚Šå¤§ãã„å ´åˆã®ã¿é©ç”¨
                    if (gaps.length > 0 && Math.abs(deltaW) > 0.001) {
                    // 1ã‚®ãƒ£ãƒƒãƒ—ã‚ãŸã‚Šã®èª¿æ•´å€¤ã‚’è¨ˆç®—ï¼ˆè² ã®å€¤ã§Phase0ã®å¹…ã«è¿‘ã¥ã‘ã‚‹ï¼‰
                    const adjustPerGap = -deltaW / gaps.length;
                    
                    // ãƒ‡ãƒãƒƒã‚°: èª¿æ•´å‰ã®ã‚®ãƒ£ãƒƒãƒ—å€¤ã‚’è¨˜éŒ²
                    const gapsBefore = [...gaps];
                    
                    // ã™ã¹ã¦ã®ã‚®ãƒ£ãƒƒãƒ—ã«èª¿æ•´å€¤ã‚’åŠ ç®—
                    for (let i = 0; i < gaps.length; i++) {
                        gaps[i] += adjustPerGap;
                        
                        // èª¿æ•´å¾Œã®ã‚®ãƒ£ãƒƒãƒ—ãŒæœ€å°ãƒ»æœ€å¤§ã®ç¯„å›²å†…ã«åã¾ã‚‹ã‚ˆã†ã«åˆ¶é™
                        const minGap = -0.2 * fontSize;
                        const maxGap = 0.8 * fontSize;
                        if (gaps[i] < minGap) gaps[i] = minGap;
                        if (gaps[i] > maxGap) gaps[i] = maxGap;
                    }
                    
                    // èª¿æ•´å¾Œã®ã‚®ãƒ£ãƒƒãƒ—ã§ä½ç½®ã‚’å†è¨ˆç®—
                    x = startX;
                    if (features.length > 0) {
                        x = startX - getInkLeft(features[0]);
                    }
                    positions[0] = x;
                    
                    for (let i = 0; i < chars.length - 1; i++) {
                        const A = features[i];
                        const B = features[i + 1];
                        const prevX = x;
                        const currentRightEdge = prevX + getInkRight(A);
                        const nextLeftEdge = currentRightEdge + gaps[i];
                        x = nextLeftEdge - getInkLeft(B);
                        positions[i + 1] = x;
                    }
                    
                    // èª¿æ•´å¾Œã®æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’å†è¨ˆç®—
                    if (positions.length > 0 && features.length > 0) {
                        const lastPos = positions[positions.length - 1];
                        const lastFeature = features[features.length - 1];
                        phase1TotalWidth = lastPos + getInkRight(lastFeature) - startX;
                    }
                    
                        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›
                        console.log(`[å¹…ã‚¢ãƒ³ã‚«ãƒ¼] Phase0å¹…: ${phase0TotalWidth.toFixed(2)}px, Phase1å¹…(èª¿æ•´å‰): ${totalWidth.toFixed(2)}px, å·®åˆ†: ${deltaW.toFixed(2)}px, èª¿æ•´å€¤/ã‚®ãƒ£ãƒƒãƒ—: ${adjustPerGap.toFixed(3)}px`);
                        console.log(`[å¹…ã‚¢ãƒ³ã‚«ãƒ¼] ã‚®ãƒ£ãƒƒãƒ—èª¿æ•´ä¾‹: [0] ${gapsBefore[0].toFixed(3)}px â†’ ${gaps[0].toFixed(3)}px (èª¿æ•´: ${adjustPerGap.toFixed(3)}px)`);
                    }
                } else {
                    // ã€ŒPhase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€ã®å ´åˆã¯å¹…ã‚¢ãƒ³ã‚«ãƒ¼ã‚’é©ç”¨ã—ãªã„
                    console.log(`[å¹…ã‚¢ãƒ³ã‚«ãƒ¼] ã‚¹ã‚­ãƒƒãƒ—: ã€ŒPhase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹ãŸã‚`);
                }
            } else {
                // Phase0ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã¾ãŸã¯æ—¢ã«Phase0ã®å¹…è¨ˆç®—ä¸­ã®å ´åˆ
                phase0TotalWidth = totalWidth;
                phase1TotalWidth = totalWidth;
            }
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«æ–‡å­—åˆ—å…¨ä½“ã®æƒ…å ±ã‚’ä¿å­˜ï¼ˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 3ç”¨ï¼‰
            // phase0_scaledã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã¯ã€å¹…ã‚¢ãƒ³ã‚«ãƒ¼é©ç”¨å‰ã®Phase1ã®å¹…ã‚’ä½¿ç”¨
            const estimatedPhase1Width = (phaseMode === "phase1" && unlearnedPairAlgorithm === "phase0_scaled") 
                ? totalWidth  // å¹…ã‚¢ãƒ³ã‚«ãƒ¼é©ç”¨å‰ã®å¹…
                : phase1TotalWidth;  // å¹…ã‚¢ãƒ³ã‚«ãƒ¼é©ç”¨å¾Œã®å¹…ï¼ˆã¾ãŸã¯Phase0ãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰
            currentTextInfo = {
                phase0TotalWidth: phase0TotalWidth,
                estimatedPhase1TotalWidth: estimatedPhase1Width,
                text: text,
                fontId: fontId,
                fontSize: fontSize
            };
            
            // è©•ä¾¡ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
            const shouldApplyWidthAnchor = phaseMode === "phase1" && unlearnedPairAlgorithm !== "phase0";
            const deltaW = phaseMode === "phase1" ? (phase1TotalWidth - phase0TotalWidth) : 0;
            const adjustPerGap = shouldApplyWidthAnchor && gaps.length > 0 && Math.abs(deltaW) > 0.001 ? 
                (-deltaW / gaps.length) : 0;
            const widthAnchorApplied = shouldApplyWidthAnchor && Math.abs(deltaW) > 0.001;
            
            return {
                positions,
                gaps,
                pairAdjusts,
                densityAdjusts,
                pairCategories,
                features,
                base,
                fontFamily,
                totalWidth: phase1TotalWidth,
                isLearned: isLearned,  // å„ãƒšã‚¢ãŒå­¦ç¿’æ¸ˆã¿ã‹ã©ã†ã‹
                evaluationData: {
                    phase0TotalWidth: phase0TotalWidth,
                    phase1TotalWidthBefore: phaseMode === "phase1" ? totalWidth : phase1TotalWidth,
                    phase1TotalWidthAfter: phase1TotalWidth,
                    deltaW: deltaW,
                    adjustPerGap: adjustPerGap,
                    widthAnchorApplied: widthAnchorApplied,
                    blendRatio: blendRatio,
                    phase0Gaps: phase0Gaps,
                    phase1Gaps: phase1Gaps,
                    blendedGaps: gaps,
                    isLearned: isLearned
                }
            };
        }

        // ============================================
        // Canvasæç”»é–¢æ•°
        // ============================================

        function drawTextWithoutKerning(ctx, text, fontId, fontSize, globalTracking = 0) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = '#2c3e50';
            ctx.font = `${fontSize}px "${fontId}"`;
            ctx.textBaseline = 'middle';
            
            const chars = Array.from(text);
            const y = ctx.canvas.height / 2;
            const startX = 50;
            let x = startX;
            
            // å…¨ä½“ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´ã‚’é©ç”¨ã—ã¦æ–‡å­—ã‚’æç”»
            chars.forEach((char, i) => {
                ctx.fillText(char, x, y);
                
                // æ¬¡ã®æ–‡å­—ã®ä½ç½®ã‚’è¨ˆç®—ï¼ˆæ–‡å­—å¹… + ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´ï¼‰
                if (i < chars.length - 1) {
                    const metrics = ctx.measureText(char);
                    const charWidth = metrics.width;
                    x += charWidth + globalTracking;
                }
            });
            
            // æ–‡å­—åˆ—å…¨ä½“ã®å¹…ã‚’è¨ˆç®—ï¼ˆæœ€å¾Œã®æ–‡å­—ã®å³ç«¯ã¾ã§ã®è·é›¢ï¼‰
            let totalWidth = 0;
            if (chars.length > 0) {
                const lastMetrics = ctx.measureText(chars[chars.length - 1]);
                const lastCharWidth = lastMetrics.width;
                totalWidth = x - startX + lastCharWidth;
            }
            
            return totalWidth;  // æ–‡å­—åˆ—å¹…ã‚’è¿”ã™
        }

        function drawTextWithKerning(ctx, text, fontId, fontSize, styleId, result) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = '#2c3e50';
            ctx.font = `${fontSize}px "${fontId}"`;
            ctx.textBaseline = 'middle';
            
            const chars = Array.from(text);
            const y = ctx.canvas.height / 2;

            // Phase1ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€æœªå­¦ç¿’ãƒšã‚¢ã®æ–‡å­—é–“ã«ç·šã‚’æç”»
            const isPhase1 = phaseMode === "phase1" && result.isLearned && result.isLearned.length > 0;
            const shouldShowUnlearned = showUnlearnedPairs && isPhase1;

            chars.forEach((char, i) => {
                const x = result.positions[i];
                ctx.fillText(char, x, y);
                
                // æœªå­¦ç¿’ãƒšã‚¢ã®æ–‡å­—é–“ã«ç·šã‚’æç”»ï¼ˆPhase1ãƒ¢ãƒ¼ãƒ‰æ™‚ã‹ã¤å¯è¦–åŒ–ãŒONã®å ´åˆã®ã¿ï¼‰
                if (shouldShowUnlearned && i < chars.length - 1 && result.isLearned[i] === false) {
                    const nextX = result.positions[i + 1];
                    
                    // æ–‡å­—ã®å³ç«¯ã¨æ¬¡ã®æ–‡å­—ã®å·¦ç«¯ã®é–“ã«ç·šã‚’å¼•ã
                    const metrics = ctx.measureText(char);
                    const charRight = x + (metrics.actualBoundingBoxRight || metrics.width * 0.5);
                    const nextMetrics = ctx.measureText(chars[i + 1]);
                    const nextCharLeft = nextX - (nextMetrics.actualBoundingBoxLeft || 0);
                    
                    // æœªå­¦ç¿’ãƒšã‚¢ã®é–“éš”ã‚’ç¤ºã™ç·šã‚’æç”»ï¼ˆåŠé€æ˜ã®èµ¤è‰²ï¼‰
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(charRight, y - fontSize * 0.4);
                    ctx.lineTo(charRight, y + fontSize * 0.4);
                    ctx.moveTo(nextCharLeft, y - fontSize * 0.4);
                    ctx.lineTo(nextCharLeft, y + fontSize * 0.4);
                    ctx.stroke();
                    
                    // é–“éš”ã®ä¸­å¤®ã«ç‚¹ç·šã‚’å¼•ãï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(charRight, y);
                    ctx.lineTo(nextCharLeft, y);
                    ctx.stroke();
                    ctx.setLineDash([]);  // ç‚¹ç·šã‚’ãƒªã‚»ãƒƒãƒˆ
                }
            });
        }

        // ============================================
        // ãƒ•ã‚©ãƒ³ãƒˆæ¤œå‡ºæ©Ÿèƒ½
        // ============================================

        // ãƒ•ã‚©ãƒ³ãƒˆãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼‰
        function isFontAvailable(fontName) {
            try {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                // åŸºæº–ãƒ•ã‚©ãƒ³ãƒˆï¼ˆç¢ºå®Ÿã«å­˜åœ¨ã™ã‚‹ãƒ•ã‚©ãƒ³ãƒˆï¼‰ã§æ¸¬å®š
                const baseFont = 'monospace';
                const testString = 'mmmmmmmmmmlli';
                context.font = `72px ${baseFont}`;
                const baseWidth = context.measureText(testString).width;
                
                // ãƒ†ã‚¹ãƒˆãƒ•ã‚©ãƒ³ãƒˆã§æ¸¬å®š
                context.font = `72px "${fontName}", ${baseFont}`;
                const testWidth = context.measureText(testString).width;
                
                // å¹…ãŒç•°ãªã‚Œã°ãƒ•ã‚©ãƒ³ãƒˆãŒåˆ©ç”¨å¯èƒ½
                // ã•ã‚‰ã«ã€æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆã®å ´åˆã¯æ—¥æœ¬èªæ–‡å­—ã§ã‚‚ãƒ†ã‚¹ãƒˆ
                if (baseWidth === testWidth && /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(fontName)) {
                    const japaneseTest = 'ã‚ã„ã†ãˆãŠ';
                    context.font = `72px ${baseFont}`;
                    const baseWidthJP = context.measureText(japaneseTest).width;
                    context.font = `72px "${fontName}", ${baseFont}`;
                    const testWidthJP = context.measureText(japaneseTest).width;
                    return baseWidthJP !== testWidthJP;
                }
                
                return baseWidth !== testWidth;
            } catch (e) {
                return false;
            }
        }

        // ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ãƒŸãƒªãƒ¼ã®è¡¨ç¤ºãƒ©ãƒ™ãƒ«
        const fontFamilyLabels = {
            "Mincho": "Minchoï¼ˆæ˜æœç³»ï¼‰",
            "Gothic": "Gothicï¼ˆè§’ã‚´ã‚·ãƒƒã‚¯ç³»ï¼‰",
            "MaruGothic": "MaruGothicï¼ˆä¸¸ã‚´ç³»ï¼‰",
            "Brush": "Brushï¼ˆç­†æ–‡å­—ç³»ï¼‰",
            "Script": "Scriptï¼ˆã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆç­†è¨˜ä½“ï¼‰",
            "Design": "Designï¼ˆè£…é£¾ç³»ãƒ»ãƒ­ã‚´é¢¨ï¼‰"
        };

        // ãƒ•ã‚©ãƒ³ãƒˆã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateFontSelect(availableFonts, defaultFonts) {
            const fontSelect = document.getElementById('fontSelect');
            
            // ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°ï¼ˆåˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã®ã¿ï¼‰
            if (availableFonts.length > 0) {
                fontSelect.innerHTML = '';
                
                // ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã”ã¨ã«åˆ†é¡
                const fontsByFamily = {
                    "Mincho": [],
                    "Gothic": [],
                    "MaruGothic": [],
                    "Brush": [],
                    "Script": [],
                    "Design": []
                };
                
                availableFonts.forEach(font => {
                    try {
                        const family = fontFamilyMap[font.name] || "Gothic";
                        if (fontsByFamily[family]) {
                            fontsByFamily[family].push(font);
                        } else {
                            fontsByFamily["Gothic"].push(font);
                        }
                    } catch (e) {
                        fontsByFamily["Gothic"].push(font);
                    }
                });
                
                // ãƒ•ã‚¡ãƒŸãƒªãƒ¼ã®é †åºã‚’å®šç¾©
                const familyOrder = ["Mincho", "Gothic", "MaruGothic", "Brush", "Script", "Design"];
                
                // optgroupã‚’ä½œæˆã—ã¦è¿½åŠ 
                familyOrder.forEach(family => {
                    const fonts = fontsByFamily[family];
                    if (fonts.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = fontFamilyLabels[family] || family;
                        fonts.forEach(font => {
                            const option = document.createElement('option');
                            option.value = font.name;
                            option.textContent = font.display;
                            optgroup.appendChild(option);
                        });
                        fontSelect.appendChild(optgroup);
                    }
                });
                
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
                if (defaultFonts.find(f => f.name === "æ¸¸æ˜æœ") && 
                    availableFonts.find(f => f.name === "æ¸¸æ˜æœ")) {
                    fontSelect.value = "æ¸¸æ˜æœ";
                } else if (availableFonts.length > 0) {
                    fontSelect.value = availableFonts[0].name;
                }
                
                // è¡¨ç¤ºã‚’æ›´æ–°
                updateDisplay();
            }
        }

        // åˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ³ãƒˆã‚’æ¤œå‡ºã—ã¦ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã«è¿½åŠ 
        function populateFontSelect() {
            const fontSelect = document.getElementById('fontSelect');
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚©ãƒ³ãƒˆã‚’è¿½åŠ 
            const defaultFonts = [
                { name: "æ¸¸æ˜æœ", display: "æ¸¸æ˜æœ" },
                { name: "æ¸¸ã‚´ã‚·ãƒƒã‚¯", display: "æ¸¸ã‚´ã‚·ãƒƒã‚¯" },
                { name: "ãƒ’ãƒ©ã‚®ãƒæ˜æœ ProN", display: "ãƒ’ãƒ©ã‚®ãƒæ˜æœ ProN" },
                { name: "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ ProN", display: "ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ ProN" },
                { name: "ãƒ¡ã‚¤ãƒªã‚ª", display: "ãƒ¡ã‚¤ãƒªã‚ª" },
                { name: "Arial", display: "Arial" },
            ];
            
            // ã¾ãšãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã‚’å³åº§ã«è¡¨ç¤ºï¼ˆãƒ•ã‚©ãƒ³ãƒˆæ¤œå‡ºã‚’å¾…ãŸãªã„ï¼‰
            fontSelect.innerHTML = '';
            defaultFonts.forEach(font => {
                const option = document.createElement('option');
                option.value = font.name;
                option.textContent = font.display;
                fontSelect.appendChild(option);
            });
            if (defaultFonts.length > 0) {
                fontSelect.value = defaultFonts[0].name;
            }
            updateDisplay();
            
            // éåŒæœŸã§ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œï¼‰
            setTimeout(() => {
                try {
                    const availableFonts = [];
                    
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã‚’å…ˆã«ãƒã‚§ãƒƒã‚¯
                    defaultFonts.forEach(font => {
                        try {
                            if (isFontAvailable(font.name)) {
                                availableFonts.push(font);
                            }
                        } catch (e) {
                            // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ•ã‚©ãƒ³ãƒˆã‚’è¿½åŠ ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                            availableFonts.push(font);
                        }
                    });
                    
                    // ã™ã¹ã¦ã®ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒãƒƒãƒå‡¦ç†ã§ãƒã‚§ãƒƒã‚¯
                    if (typeof commonFonts !== 'undefined' && Array.isArray(commonFonts)) {
                        // ãƒãƒƒãƒã‚µã‚¤ã‚ºï¼ˆä¸€åº¦ã«ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ•ã‚©ãƒ³ãƒˆæ•°ï¼‰
                        const batchSize = 10;
                        let currentIndex = 0;
                        
                        // ãƒãƒƒãƒå‡¦ç†é–¢æ•°
                        const processBatch = () => {
                            const endIndex = Math.min(currentIndex + batchSize, commonFonts.length);
                            
                            for (let i = currentIndex; i < endIndex; i++) {
                                const fontName = commonFonts[i];
                                try {
                                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã«å«ã¾ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
                                    if (!defaultFonts.find(f => f.name === fontName)) {
                                        if (isFontAvailable(fontName)) {
                                            availableFonts.push({ name: fontName, display: fontName });
                                        }
                                    }
                                } catch (e) {
                                    // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã—ã¦ç¶šè¡Œ
                                }
                            }
                            
                            currentIndex = endIndex;
                            
                            // ã¾ã å‡¦ç†ã™ã‚‹ãƒ•ã‚©ãƒ³ãƒˆãŒã‚ã‚‹å ´åˆ
                            if (currentIndex < commonFonts.length) {
                                // UIã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã‚ˆã†ã«ã€æ¬¡ã®ãƒãƒƒãƒã‚’éåŒæœŸã§å‡¦ç†
                                setTimeout(processBatch, 10);
                            } else {
                                // ã™ã¹ã¦ã®ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯å®Œäº†ã—ãŸã‚‰ã€ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
                                updateFontSelect(availableFonts, defaultFonts);
                            }
                        };
                        
                        // æœ€åˆã®ãƒãƒƒãƒã‚’é–‹å§‹
                        processBatch();
                    } else {
                        // commonFontsãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã®ã¿ã§æ›´æ–°
                        updateFontSelect(availableFonts, defaultFonts);
                    }
                } catch (e) {
                    console.error('ãƒ•ã‚©ãƒ³ãƒˆæ¤œå‡ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', e);
                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã¯è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã®ã§å•é¡Œãªã—
                }
            }, 200);
        }

        // ============================================
        // UIæ›´æ–°é–¢æ•°
        // ============================================
        
        // ============================================
        // è©•ä¾¡ãƒ‘ãƒãƒ«ã®æ›´æ–°
        // ============================================
        
        function updateEvaluationPanel(result) {
            const panel = document.getElementById('evaluationPanel');
            if (!panel) return;
            
            // Phase1ãƒ¢ãƒ¼ãƒ‰ã®æ™‚ã®ã¿è¡¨ç¤º
            if (phaseMode === "phase1" && phase1Model) {
                panel.style.display = 'block';
                
                const evalData = result.evaluationData || {};
                
                // å¹…ã‚¢ãƒ³ã‚«ãƒ¼ã®è©•ä¾¡
                if (evalData.phase0TotalWidth !== undefined) {
                    document.getElementById('evalPhase0Width').textContent = evalData.phase0TotalWidth.toFixed(2);
                }
                if (evalData.phase1TotalWidthBefore !== undefined) {
                    document.getElementById('evalPhase1WidthBefore').textContent = evalData.phase1TotalWidthBefore.toFixed(2);
                }
                if (evalData.phase1TotalWidthAfter !== undefined) {
                    document.getElementById('evalPhase1WidthAfter').textContent = evalData.phase1TotalWidthAfter.toFixed(2);
                }
                if (evalData.deltaW !== undefined) {
                    const deltaW = evalData.deltaW;
                    const deltaElement = document.getElementById('evalWidthDelta');
                    deltaElement.textContent = `${deltaW > 0 ? '+' : ''}${deltaW.toFixed(2)}`;
                    deltaElement.style.color = Math.abs(deltaW) > 0.1 ? (deltaW > 0 ? '#e74c3c' : '#27ae60') : '#7f8c8d';
                }
                if (evalData.adjustPerGap !== undefined) {
                    const adjust = evalData.adjustPerGap;
                    const adjustElement = document.getElementById('evalAdjustPerGap');
                    adjustElement.textContent = `${adjust > 0 ? '+' : ''}${adjust.toFixed(3)}`;
                    adjustElement.style.color = Math.abs(adjust) > 0.01 ? (adjust > 0 ? '#e74c3c' : '#27ae60') : '#7f8c8d';
                }
                document.getElementById('evalWidthAnchorApplied').textContent = 
                    evalData.widthAnchorApplied ? 'é©ç”¨æ¸ˆã¿' : 'æœªé©ç”¨';
                
                // ãƒ–ãƒ¬ãƒ³ãƒ‰åŠ¹æœã®è©•ä¾¡
                const blendPercent = (blendRatio * 100).toFixed(0);
                document.getElementById('evalBlendRatio').textContent = `${blendPercent}%`;
                
                // Phase0ã¨Phase1ã®ã‚®ãƒ£ãƒƒãƒ—ã‚’è¨ˆç®—
                if (evalData.phase0Gaps && evalData.phase0Gaps.length > 0 && 
                    evalData.phase1Gaps && evalData.phase1Gaps.length > 0) {
                    const avgPhase0Gap = evalData.phase0Gaps.reduce((a, b) => a + b, 0) / evalData.phase0Gaps.length;
                    const avgPhase1Gap = evalData.phase1Gaps.reduce((a, b) => a + b, 0) / evalData.phase1Gaps.length;
                    const avgBlendedGap = evalData.blendedGaps ? 
                        (evalData.blendedGaps.reduce((a, b) => a + b, 0) / evalData.blendedGaps.length) : avgPhase1Gap;
                    
                    document.getElementById('evalAvgPhase0Gap').textContent = avgPhase0Gap.toFixed(2);
                    document.getElementById('evalAvgPhase1Gap').textContent = avgPhase1Gap.toFixed(2);
                    document.getElementById('evalAvgBlendedGap').textContent = avgBlendedGap.toFixed(2);
                    
                    // ã‚®ãƒ£ãƒƒãƒ—å¤‰åŒ–ç‡ï¼ˆPhase0ã‹ã‚‰ãƒ–ãƒ¬ãƒ³ãƒ‰å¾Œã¸ã®å¤‰åŒ–ï¼‰
                    if (avgPhase0Gap !== 0) {
                        const changeRate = ((avgBlendedGap - avgPhase0Gap) / avgPhase0Gap * 100);
                        const changeElement = document.getElementById('evalGapChangeRate');
                        changeElement.textContent = `${changeRate > 0 ? '+' : ''}${changeRate.toFixed(1)}%`;
                        changeElement.style.color = Math.abs(changeRate) > 5 ? (changeRate > 0 ? '#e74c3c' : '#27ae60') : '#7f8c8d';
                    } else {
                        document.getElementById('evalGapChangeRate').textContent = '-';
                    }
                    
                    // æ¨™æº–åå·®
                    if (evalData.blendedGaps && evalData.blendedGaps.length > 0) {
                        const mean = avgBlendedGap;
                        const variance = evalData.blendedGaps.reduce((sum, gap) => sum + Math.pow(gap - mean, 2), 0) / evalData.blendedGaps.length;
                        const stdDev = Math.sqrt(variance);
                        document.getElementById('evalGapStdDev').textContent = stdDev.toFixed(2);
                    } else {
                        document.getElementById('evalGapStdDev').textContent = '-';
                    }
                } else {
                    document.getElementById('evalAvgPhase0Gap').textContent = '-';
                    document.getElementById('evalAvgPhase1Gap').textContent = '-';
                    document.getElementById('evalAvgBlendedGap').textContent = '-';
                    document.getElementById('evalGapChangeRate').textContent = '-';
                    document.getElementById('evalGapStdDev').textContent = '-';
                }
                
                // ç·åˆè©•ä¾¡
                if (evalData.isLearned && evalData.isLearned.length > 0) {
                    const learnedCount = evalData.isLearned.filter(x => x).length;
                    const totalCount = evalData.isLearned.length;
                    document.getElementById('evalLearnedPairs').textContent = learnedCount;
                    document.getElementById('evalTotalPairs').textContent = totalCount;
                    document.getElementById('evalUnlearnedPairs').textContent = (totalCount - learnedCount);
                } else {
                    document.getElementById('evalLearnedPairs').textContent = '-';
                    document.getElementById('evalTotalPairs').textContent = '-';
                    document.getElementById('evalUnlearnedPairs').textContent = '-';
                }
            } else {
                panel.style.display = 'none';
            }
        }

        function updateDisplay() {
            const text = document.getElementById('textInput').value || 'Wave';
            const fontSelect = document.getElementById('fontSelect');
            const fontCustomInput = document.getElementById('fontCustomInput');
            
            // ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆå…¥åŠ›ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’å„ªå…ˆã€ãªã‘ã‚Œã°ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã®å€¤ã‚’ä½¿ç”¨
            let fontId = fontSelect.value;
            if (fontCustomInput && fontCustomInput.value.trim()) {
                fontId = fontCustomInput.value.trim();
            }
            if (!fontId) {
                return; // ãƒ•ã‚©ãƒ³ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
            }
            
            const styleId = document.getElementById('styleSelect').value;
            const fontSize = parseInt(document.getElementById('fontSizeInput').value) || 64;
            const globalTracking = parseFloat(document.getElementById('trackingSlider').value) || 0;
            const currentPhaseMode = document.getElementById('phaseModeSelect').value;

            const canvasBefore = document.getElementById('canvasBefore');
            const canvasAfter = document.getElementById('canvasAfter');
            const ctxBefore = canvasBefore.getContext('2d');
            const ctxAfter = canvasAfter.getContext('2d');
            
            // ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°
            const canvasBeforeLabel = document.getElementById('canvasBeforeLabel');
            const canvasAfterLabel = document.getElementById('canvasAfterLabel');
            
            if (currentPhaseMode === "compare") {
                // æ¯”è¼ƒãƒ¢ãƒ¼ãƒ‰ï¼šå·¦=Phase0ã€å³=Phase1
                canvasBeforeLabel.textContent = "Phase0ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼‰";
                canvasAfterLabel.textContent = "Phase1ï¼ˆå­¦ç¿’å€¤ï¼‰";
                
                // Phase0ã§æç”»
                phaseMode = "phase0";
                const resultPhase0 = computeKerningPositions(text, fontId, fontSize, styleId, globalTracking);
                drawTextWithKerning(ctxBefore, text, fontId, fontSize, styleId, resultPhase0);
                
                // Phase1ã§æç”»
                phaseMode = "phase1";
                const resultPhase1 = computeKerningPositions(text, fontId, fontSize, styleId, globalTracking);
                drawTextWithKerning(ctxAfter, text, fontId, fontSize, styleId, resultPhase1);
                
                // æƒ…å ±ãƒ‘ãƒãƒ«ã¯Phase1ã®çµæœã‚’è¡¨ç¤º
                updateInfoPanel(resultPhase1, text);
                
                // è©•ä¾¡ãƒ‘ãƒãƒ«æ›´æ–°ï¼ˆPhase1ã®çµæœã‚’ä½¿ç”¨ï¼‰
                updateEvaluationPanel(resultPhase1);
                
                // ãƒ¢ãƒ¼ãƒ‰ã‚’å…ƒã«æˆ»ã™
                phaseMode = currentPhaseMode;
            } else {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šå·¦=ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å‰ã€å³=é¸æŠã—ãŸãƒ¢ãƒ¼ãƒ‰
                canvasBeforeLabel.textContent = "ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å‰ï¼ˆå›ºå®šãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ï¼‰";
                const modeLabel = currentPhaseMode === "phase1" ? "Phase1ï¼ˆå­¦ç¿’å€¤ï¼‰" : "Phase0ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼‰";
                canvasAfterLabel.textContent = `ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å¾Œï¼ˆ${modeLabel}ï¼‰`;
                
                phaseMode = currentPhaseMode;
                
                // ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å‰ï¼ˆå›ºå®šãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚° + å…¨ä½“ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´ï¼‰
                drawTextWithoutKerning(ctxBefore, text, fontId, fontSize, globalTracking);

                // ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°å¾Œï¼ˆé¸æŠã—ãŸãƒ¢ãƒ¼ãƒ‰ï¼‰
                const result = computeKerningPositions(text, fontId, fontSize, styleId, globalTracking);
                drawTextWithKerning(ctxAfter, text, fontId, fontSize, styleId, result);

                // æƒ…å ±ãƒ‘ãƒãƒ«æ›´æ–°
                updateInfoPanel(result, text);
                
                // è©•ä¾¡ãƒ‘ãƒãƒ«æ›´æ–°
                updateEvaluationPanel(result);
            }
        }

        function updateInfoPanel(result, text) {
            document.getElementById('infoFontFamily').textContent = result.fontFamily;
            document.getElementById('infoBaseTracking').textContent = 
                `${result.base.toFixed(2)}px (${result.fontFamily} Ã— ${document.getElementById('styleSelect').value})`;

            const charTypes = result.features.map((f, i) => 
                `${text[i]}: ${f.charType} (${f.density})`
            ).join(', ');
            document.getElementById('infoCharTypes').textContent = charTypes;

            const pairInfo = result.pairCategories.map((cat, i) => 
                `${text[i]}-${text[i+1]}: ${cat} (${result.pairAdjusts[i].toFixed(2)}px)`
            ).join(', ');
            document.getElementById('infoPairAdjusts').textContent = pairInfo || '-';

            const densityInfo = result.features.slice(0, -1).map((f, i) => {
                const next = result.features[i + 1];
                return `${f.density}-${next.density} (${result.densityAdjusts[i].toFixed(2)}px)`;
            }).join(', ');
            document.getElementById('infoDensityAdjusts').textContent = densityInfo || '-';

            const gapsInfo = result.gaps.map((gap, i) => 
                `${text[i]}-${text[i+1]}: ${gap.toFixed(2)}px`
            ).join(', ');
            document.getElementById('infoFinalGaps').textContent = gapsInfo || '-';
            
            // æ–‡å­—ã”ã¨ã®è©³ç´°æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
            const charDetailsContainer = document.getElementById('charDetails');
            charDetailsContainer.innerHTML = '';
            
            result.features.forEach((feature, i) => {
                const char = text[i];
                const detailDiv = document.createElement('div');
                detailDiv.className = 'info-item';
                detailDiv.style.cssText = 'background: white; padding: 15px; border-radius: 4px; border-left: 3px solid #3498db;';
                
                detailDiv.innerHTML = `
                    <strong style="display: block; font-size: 14px; color: #2c3e50; margin-bottom: 10px;">æ–‡å­—: "${char}"</strong>
                    <div style="font-size: 12px; line-height: 1.8;">
                        <div><strong>æ–‡å­—ç¨®:</strong> ${feature.charCategory || '-'}</div>
                        <div><strong>æ–‡å­—ã‚¿ã‚¤ãƒ—:</strong> ${feature.charType || '-'}</div>
                        <div><strong>é»’å¯†åº¦:</strong> ${feature.density || '-'}</div>
                        <div><strong>fillRatio:</strong> ${(feature.fillRatio || 0).toFixed(3)}</div>
                        <div><strong>aspectRatio:</strong> ${(feature.aspectRatio || 0).toFixed(3)}</div>
                        <div><strong>å¹…:</strong> ${(feature.width || 0).toFixed(2)}px</div>
                        <div><strong>é«˜ã•:</strong> ${(feature.height || 0).toFixed(2)}px</div>
                    </div>
                `;
                
                charDetailsContainer.appendChild(detailDiv);
            });
        }

        // ============================================
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        // ============================================

        document.getElementById('textInput').addEventListener('input', updateDisplay);
        document.getElementById('fontSelect').addEventListener('change', function() {
            // ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰ã€ã‚«ã‚¹ã‚¿ãƒ å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
            const fontCustomInput = document.getElementById('fontCustomInput');
            if (fontCustomInput) {
                fontCustomInput.value = '';
            }
            updateDisplay();
        });
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
        const fontCustomInput = document.getElementById('fontCustomInput');
        if (fontCustomInput) {
            fontCustomInput.addEventListener('input', function() {
                // ã‚«ã‚¹ã‚¿ãƒ å…¥åŠ›ãŒã‚ã‚‹å ´åˆã¯ã€ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã®é¸æŠã‚’ã‚¯ãƒªã‚¢
                if (this.value.trim()) {
                    document.getElementById('fontSelect').value = '';
                }
                updateDisplay();
            });
        }
        document.getElementById('styleSelect').addEventListener('change', updateDisplay);
        document.getElementById('fontSizeInput').addEventListener('input', updateDisplay);
        
        // Phaseãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        document.getElementById('phaseModeSelect').addEventListener('change', function() {
            phaseMode = this.value;
            // Phase1ãƒ¢ãƒ¼ãƒ‰ã®æ™‚ã®ã¿æœªå­¦ç¿’ãƒšã‚¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã¨å¯è¦–åŒ–ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã€ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’è¡¨ç¤º
            const unlearnedPairAlgorithmGroup = document.getElementById('unlearnedPairAlgorithmGroup');
            if (unlearnedPairAlgorithmGroup) {
                unlearnedPairAlgorithmGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            const showUnlearnedPairsGroup = document.getElementById('showUnlearnedPairsGroup');
            if (showUnlearnedPairsGroup) {
                showUnlearnedPairsGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            const blendRatioGroup = document.getElementById('blendRatioGroup');
            if (blendRatioGroup) {
                blendRatioGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            updateDisplay();
        });
        
        // æœªå­¦ç¿’ãƒšã‚¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®é¸æŠ
        const unlearnedPairAlgorithmSelect = document.getElementById('unlearnedPairAlgorithmSelect');
        if (unlearnedPairAlgorithmSelect) {
            unlearnedPairAlgorithmSelect.addEventListener('change', function() {
                unlearnedPairAlgorithm = this.value;
                updateDisplay();
            });
        }
        
        // æœªå­¦ç¿’ãƒšã‚¢ã®å¯è¦–åŒ–ã®On/Off
        const showUnlearnedPairsCheckbox = document.getElementById('showUnlearnedPairsCheckbox');
        if (showUnlearnedPairsCheckbox) {
            showUnlearnedPairsCheckbox.addEventListener('change', function() {
                showUnlearnedPairs = this.checked;
                updateDisplay();
            });
        }
        
        // å…¨ä½“ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¿æ•´ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼
        const trackingSlider = document.getElementById('trackingSlider');
        const trackingValue = document.getElementById('trackingValue');
        
        trackingSlider.addEventListener('input', function() {
            const value = parseFloat(this.value);
            trackingValue.textContent = value > 0 ? `+${value}px` : `${value}px`;
            updateDisplay();
        });
        
        // Phase0ã¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
        const blendRatioSlider = document.getElementById('blendRatioSlider');
        const blendRatioValue = document.getElementById('blendRatioValue');
        const blendRatioDescription = document.getElementById('blendRatioDescription');
        
        if (blendRatioSlider && blendRatioValue && blendRatioDescription) {
            // ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ã®èª¬æ˜æ–‡ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            function updateBlendRatioDescription(ratio) {
                if (ratio <= 0) {
                    blendRatioDescription.textContent = 'Phase0ã®ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’100%ä½¿ç”¨';
                } else if (ratio >= 100) {
                    blendRatioDescription.textContent = 'Phase1ã®å­¦ç¿’å€¤ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’100%ä½¿ç”¨';
                } else {
                    const phase0Percent = (100 - ratio).toFixed(0);
                    const phase1Percent = ratio.toFixed(0);
                    blendRatioDescription.textContent = `Phase0: ${phase0Percent}% + Phase1: ${phase1Percent}% ã§ãƒ–ãƒ¬ãƒ³ãƒ‰`;
                }
            }
            
            blendRatioSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                blendRatio = value / 100.0;  // 0.0ï½1.0ã®ç¯„å›²ã«å¤‰æ›
                blendRatioValue.textContent = `${value}%`;
                updateBlendRatioDescription(value);
                updateDisplay();
            });
            
            // åˆæœŸè¡¨ç¤ºã‚’æ›´æ–°
            updateBlendRatioDescription(0);
        }
        
        // åˆæœŸè¡¨ç¤º
        trackingValue.textContent = '0px';

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«Phase1ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€ãƒ•ã‚©ãƒ³ãƒˆæ¤œå‡ºã‚’å®Ÿè¡Œ
        document.addEventListener('DOMContentLoaded', function() {
            // åˆæœŸè¡¨ç¤ºæ™‚ã«æœªå­¦ç¿’ãƒšã‚¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã¨å¯è¦–åŒ–ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã€ãƒ–ãƒ¬ãƒ³ãƒ‰æ¯”ç‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’è¨­å®š
            const unlearnedPairAlgorithmGroup = document.getElementById('unlearnedPairAlgorithmGroup');
            if (unlearnedPairAlgorithmGroup) {
                unlearnedPairAlgorithmGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            const showUnlearnedPairsGroup = document.getElementById('showUnlearnedPairsGroup');
            if (showUnlearnedPairsGroup) {
                showUnlearnedPairsGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            const blendRatioGroup = document.getElementById('blendRatioGroup');
            if (blendRatioGroup) {
                blendRatioGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            
            loadPhase1Model().then(() => {
                populateFontSelect();
            }).catch(() => {
                populateFontSelect();
            });
        });
        
        // æ—¢ã«DOMãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        if (document.readyState === 'loading') {
            // DOMContentLoadedã‚’å¾…ã¤
        } else {
            // æ—¢ã«èª­ã¿è¾¼ã¿æ¸ˆã¿
            // åˆæœŸè¡¨ç¤ºæ™‚ã«æœªå­¦ç¿’ãƒšã‚¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã¨å¯è¦–åŒ–ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’è¨­å®š
            const unlearnedPairAlgorithmGroup = document.getElementById('unlearnedPairAlgorithmGroup');
            if (unlearnedPairAlgorithmGroup) {
                unlearnedPairAlgorithmGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            const showUnlearnedPairsGroup = document.getElementById('showUnlearnedPairsGroup');
            if (showUnlearnedPairsGroup) {
                showUnlearnedPairsGroup.style.display = (phaseMode === "phase1") ? "flex" : "none";
            }
            
            loadPhase1Model().then(() => {
                populateFontSelect();
            }).catch(() => {
                populateFontSelect();
            });
        }
    </script>
</body>
</html>

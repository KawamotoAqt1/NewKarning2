またネガティブ質問ですが、文字特徴の組み合わせを考える場合、その文字がどの特徴を持ったものかを判定するのはどこでやりますか？

結論からいうと：

> 「この文字はどの特徴カテゴリか？」の判定は、
> **“文字レイアウトエンジン内の前処理”として、自動でやります。**
> 人手で全部タグ付けする世界には行かない想定です。

もう少し具体的に噛み砕きます。

---

## どこで判定するのか？：場所のイメージ

システム的には、こんな感じのモジュールを作るイメージです。

* モジュール名（仮）：`CharFeatureResolver`
* 役割：
  `（文字, フォント） → 特徴情報` を返す

```js
// ざっくりイメージ
const f = resolveCharFeatures(char, fontId, fontSize);

/*
f = {
  charType: "VERTICAL_HEAVY" | "CURVE" | ...,
  density: "LIGHT" | "MEDIUM" | "HEAVY",
  width: number,
  height: number,
}
*/
```

この `resolveCharFeatures` を、
**カーニング計算の前処理として、フロント or サーバーのどちらかで呼ぶ** 形になります。

---

## どうやって判定するのか？：3段階の自動判定

### ① ざっくり文字種での分類（超軽いルール）

ここは **Unicode / 文字種** で切るだけです。

* 漢字 → `KANJI`
* ひらがな → `HIRAGANA`
* カタカナ → `KATAKANA`
* 英大文字 → `LATIN_UPPER`
* 英小文字 → `LATIN_LOWER`
* 記号 → `SYMBOL`

これは JS でも簡単に判定できます（正規表現 or Unicodeブロック）。

ここまでで、
**「和文か欧文か」「ひらがなか漢字か」くらいのラフな性格分け**ができます。

---

### ② Canvas or アウトラインからの“形状ベース判定”

ここが本質です。
あなたの環境だと **文字＋フォント＋アウトライン** が取れるので、2パターンあります。

#### パターンA：ブラウザCanvasで判定（フロント）【実装済み】

**実装アルゴリズム**：

1. オフスクリーンCanvasに文字を描画（白背景、黒文字）
2. `measureText`でバウンディングボックス情報を取得（参考用）
3. **第1パス：実際に描画された黒ピクセルの範囲を検出**
   - バウンディングボックス内を走査
   - 黒ピクセル（RGB平均 < 200 && α > 100）のminX, maxX, minY, maxYを記録
4. **第2パス：実際の描画領域内でのfillRatioを計算**
   - minX～maxX, minY～maxYの範囲内のみで黒ピクセルをカウント
   - `fillRatio = filledPixels / totalPixels`
5. **実際の描画領域から幅・高さを計算**
   - `width = maxX - minX + 1`
   - `height = maxY - minY + 1`
   - `aspectRatio = width / height`
6. 文字種（Unicode範囲）と組み合わせてcharTypeを判定

**実装済みの閾値**：

```js
// 黒密度
if (fillRatio > 0.45) → HEAVY
else if (fillRatio < 0.20) → LIGHT
else → MEDIUM

// 文字タイプ判定（文字種 + fillRatio + aspectRatio）
// 詳細は3.1節を参照
```

**重要なポイント**：
* **すべての計算は実際の描画領域に基づく**（人が見たものと同じ値）
* `width`と`height`は`measureText`ではなく、実際の描画領域から計算
* `fillRatio`も実際の描画領域内のみで計算（余白を含まない）

#### パターンB：AIファイルのアウトラインから判定（サーバー or バッチ）

IllustratorアウトラインをSVG化して：

* パスの外接矩形 → width/height
* パス面積 → 黒密度
* 線分や曲線の比率 → 斜線強めかどうか（余裕があれば）

という形で **同じような特徴** を取れます。

→ こちらは「学習用のバッチ処理」に向いています。
日常の実行時は Canvas ベース（パターンA）だけでもOK。

---

### ③ キャッシュして“何度も判定しない”

毎回全文字を分析すると重くなるので、
`（文字, フォントId）` をキーに **キャッシュ** します。

* フロントなら：メモリ or localStorage
* サーバーなら：DB or ファイル

```js
// 実装済み：fontSizeもキャッシュキーに含める
const cacheKey = `${fontId}:${char}:${fontSize}`;
if (featureCache[cacheKey]) return featureCache[cacheKey];
const f = resolveCharFeatures(char, fontId, fontSize);
featureCache[cacheKey] = f;
return f;
```

**実装済みのキャッシュ構造**：
* キー：`fontId:char:fontSize`（フォントサイズも含める）
* 値：`{ width, height, fillRatio, aspectRatio, charType, density, charCategory }`

こうすると：

* よく出る「佐」「藤」「田」「中」などは、**最初だけ分析して、あとは使い回し**
* 全部の漢字を事前に分析する必要はない
  → 実際にユーザーが入力してきた文字だけでよい

---

## じゃあ「判定ロジック作るのが地獄では？」問題

ネガティブ目線でここが心配だと思いますが、
**本当に欲しいのは“ざっくりカテゴリ”だけ**です。

* 完全に正しい分類じゃなくていい
* 多少誤分類されても、ロジックベースのカーニングであれば「極端に変」は起こりにくい
* どうしても気になるケースは、後で個別補正（文字テーブル）を足せばよい

つまり：

> 文字特徴の判定は「モデルのような重い学習」ではなく、
> **“ヒューリスティック＋少しの実測” でサクッと決めるレイヤー**に留める。

ここに何千サンプルも学習させる世界には行かないです。

---

## まとめると

* 特徴の判定は **専用モジュール（CharFeatureResolver）** を作って自動でやる
* 中身は：

  * 文字種（漢字/ひらがな/英字）でざっくり分類
  * Canvas or アウトラインから黒密度・縦横比などを推定
  * その組み合わせで `VERTICAL_HEAVY` などのカテゴリに落とし込む
* 一度判定した結果は `(文字, フォント)` 単位でキャッシュ
* 精度は「ざっくりでOK」で、完璧な判定は最初から目指さない

なので、

> 「文字特徴の判定のために、無限の文字セットを人間が管理…」
> という悪夢ルートには行きません。

---

## 9. 実装済み機能

### 9.1 文字特徴量自動判定（CharFeatureResolver）

**実装済み**：
* `getCharCategory(char)`: Unicode範囲で文字種を判定
* `analyzeCharWithCanvas(char, fontId, fontSize)`: Canvasベースで形状分析
* `resolveCharFeatures(char, fontId, fontSize)`: 文字特徴量を統合判定
* キャッシュ機能（`fontId:char:fontSize`をキーに）

**出力される特徴量**：
```js
{
  width: number,        // 実際の描画領域の幅（px）
  height: number,       // 実際の描画領域の高さ（px）
  fillRatio: number,    // 黒ピクセル密度（0.0～1.0）
  aspectRatio: number, // 縦横比（width / height）
  charType: string,     // VERTICAL_HEAVY, CURVE, COMPLEX等
  density: string,      // HEAVY, MEDIUM, LIGHT
  charCategory: string  // KANJI, HIRAGANA, LATIN_UPPER等
}
```

### 9.2 全体トラッキング調整

**実装済み**：
* `globalTracking`パラメータ（-50px ～ +50px）
* UIスライダーでリアルタイム調整可能
* すべての文字ペアに一様に適用

### 9.3 フォント検出機能

**実装済み**：
* PCで利用可能なフォントを動的に検出
* フォントファミリーごとに分類表示（optgroup）
* カスタムフォント名の直接入力に対応

---

## 10. 実装の詳細アルゴリズム

### 10.1 `analyzeCharWithCanvas`の詳細フロー

1. Canvas作成・フォント設定
2. `measureText`でバウンディングボックス取得（参考用）
3. 文字を描画（白背景、黒文字）
4. `getImageData`でピクセルデータ取得
5. **第1パス：実際の描画範囲検出**
   - バウンディングボックス内を走査
   - 黒ピクセル（gray < 200 && a > 100）のminX, maxX, minY, maxYを記録
6. **第2パス：fillRatio計算**
   - minX～maxX, minY～maxYの範囲内のみで黒ピクセルをカウント
   - `fillRatio = filledPixels / totalPixels`
7. **実際の描画領域から幅・高さを計算**
   - `width = maxX - minX + 1`
   - `height = maxY - minY + 1`
   - `aspectRatio = width / height`
8. エラーハンドリング：失敗時はデフォルト値を返す

### 10.2 文字タイプ判定の詳細ロジック

**実装済みの判定ルール**：

```js
// 漢字（KANJI）
if (aspectRatio < 0.7) {
  charType = density === "HEAVY" ? "VERTICAL_HEAVY" : "VERTICAL_LIGHT";
} else {
  charType = "COMPLEX";
}

// かな（HIRAGANA/KATAKANA）
if (fillRatio < 0.3 && 0.8 < aspectRatio < 1.25) {
  charType = "CURVE";
} else if (aspectRatio > 1.3 || aspectRatio < 0.6) {
  charType = "DIAGONAL";
} else {
  charType = "KANA";
}

// ラテン文字
if (charCategory === "LATIN_UPPER") charType = "LATIN_UPPER";
if (charCategory === "LATIN_LOWER") charType = "LATIN_LOWER";

// 記号・その他
if (fillRatio > 0.6) charType = "CURVE";
else charType = "MIXED";
```

---

## 11. 今後の改善点

* 特殊な文字ペアの個別補正テーブル
* フォントサイズに応じた動的な閾値調整
* 縦書き対応
* より高度な形状分析（斜線検出など）
